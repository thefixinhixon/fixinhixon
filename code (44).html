<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Runner</title>
    <style>
        /* CSS remains the same */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            color: white;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column; /* Stack canvas and UI */
        }
        #gameContainer {
            position: relative; /* Needed for absolute positioning of UI */
            width: 80vw; /* Responsive width */
            max-width: 800px; /* Max width */
            aspect-ratio: 16 / 9; /* Maintain aspect ratio */
            border: 1px solid #555;
        }
        #gameCanvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
        }
        #uiContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none; /* Allow clicks to pass through to canvas if needed */
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
        #score { }
        #highScoreDisplay { }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 28px;
            pointer-events: all; /* Capture clicks */
        }
        #gameOverScreen h2 {
            margin-bottom: 15px;
        }
        #finalScore, #sessionHighScore {
            margin-bottom: 20px;
        }
        #restartButton {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        #restartButton:hover {
            background-color: #45a049;
        }
        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            background-color: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="score">Score: 0</div>
            <div id="highScoreDisplay">High Score: 0</div>
        </div>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <div id="finalScore">Your Score: 0</div>
            <div id="sessionHighScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
         <div id="startMessage">Loading Assets...</div> <!-- Changed initial message -->
    </div>

    <!-- Import map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // --- CHANGE START ---
        // Import GLTFLoader
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        // --- CHANGE END ---

        // --- Configuration ---
        const LANE_WIDTH = 2.5;
        const LANES = [-LANE_WIDTH, 0, LANE_WIDTH]; // X-coordinates of the lanes
        // --- CHANGE START ---
        // Player start Y position will be calculated after model load based on its height
        const PLAYER_START_POS = new THREE.Vector3(0, 0, 10);
        const PLAYER_MODEL_PATH = 'raccoon.glb'; // Path to your model
        const PLAYER_MODEL_SCALE = 0.5; // Adjust this scale based on your model size!
        // --- CHANGE END ---
        const INITIAL_GAME_SPEED = 8;
        const MAX_GAME_SPEED = 30;
        const SPEED_INCREASE_RATE = 0.1;
        const OBSTACLE_SPAWN_Z = -50;
        const OBSTACLE_DESPAWN_Z = 15;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 0.8;
        const OBSTACLE_SPAWN_INTERVAL_MAX = 2.0;
        const JUMP_VELOCITY = 10;
        const GRAVITY = 25;
        const HIGH_SCORE_KEY = 'raccoonRunnerHighScore';

        // --- Game State ---
        let scene, camera, renderer, clock, player;
        let gameSpeed = INITIAL_GAME_SPEED;
        let obstacles = [];
        let currentLane = 1;
        let score = 0;
        let highScore = 0;
        let timeSinceLastSpawn = 0;
        let nextSpawnInterval = calculateNextSpawnInterval();
        let isJumping = false;
        let playerVelocityY = 0;
        let gameState = 'loading'; // 'loading', 'waiting', 'playing', 'gameOver'
        let animationFrameId = null;
        // --- CHANGE START ---
        let playerMixer = null; // For animations
        let playerBoundingBox = new THREE.Box3(); // Separate bounding box variable
        let playerHeight = 1; // Default height, will be updated
        let assetsLoaded = false;
        // --- CHANGE END ---

        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameContainer = document.getElementById('gameContainer');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScoreDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const sessionHighScoreElement = document.getElementById('sessionHighScore');
        const restartButton = document.getElementById('restartButton');
        const startMessage = document.getElementById('startMessage');

        // --- Initialization ---
        function init() {
            // Basic Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            clock = new THREE.Clock();

            // Camera
            const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 4, 15);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lights (same as before)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Ground (same as before)
            const groundGeometry = new THREE.PlaneGeometry(20, 150);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

             // Load High Score
            loadHighScore();
            updateHighScoreDisplay();

            // --- CHANGE START ---
            // Load Player Model
            loadPlayerModel(() => {
                // This callback runs when the model is loaded successfully
                assetsLoaded = true;
                gameState = 'waiting'; // Move to waiting state
                showStartMessage("Press Any Key or Click to Start"); // Update message
                // Add event listeners *after* assets are loaded
                window.addEventListener('keydown', startGameOnce);
                window.addEventListener('mousedown', startGameOnce);
            });
            // --- CHANGE END ---


            // Event Listeners (moved some to load callback)
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown); // Keep general keydown for movement/jump
            restartButton.addEventListener('click', resetGame);

            // Start the animation loop immediately for loading screen/potential idle animations
            animate();
        }

        // --- CHANGE START ---
        // Function to load the GLB model
        function loadPlayerModel(onLoadCallback) {
            const loader = new GLTFLoader();
            loader.load(
                PLAYER_MODEL_PATH,
                // onLoad: Success callback
                (gltf) => {
                    player = gltf.scene; // The loaded model group

                    // Configure the loaded model
                    player.scale.set(PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE);
                    player.rotation.y = Math.PI; // Rotate 180 degrees to face down the track
                    player.position.copy(PLAYER_START_POS);

                    // Enable shadows for all meshes within the model
                    player.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            // Optional: child.receiveShadow = true; // If parts of raccoon should receive shadows
                        }
                    });

                    // Calculate bounding box AFTER scaling and adding to scene (pre-add)
                    // We need a temporary add to calculate box based on world matrix
                    scene.add(player);
                    playerBoundingBox.setFromObject(player, true); // true for precise check
                    const playerSize = new THREE.Vector3();
                    playerBoundingBox.getSize(playerSize);
                    playerHeight = playerSize.y;

                    // Set correct initial Y position based on calculated height
                    player.position.y = playerHeight / 2; // Assumes model origin is at its base

                    // Recalculate bounding box AFTER final positioning
                    playerBoundingBox.setFromObject(player, true);

                    console.log("Player model loaded. Height:", playerHeight);

                    // Setup Animation Mixer (if animations exist)
                    if (gltf.animations && gltf.animations.length) {
                        playerMixer = new THREE.AnimationMixer(player);
                        // Play the first animation clip found (you might want to find one by name)
                        const action = playerMixer.clipAction(gltf.animations[0]); // Or find by name: gltf.animations.find(clip => clip.name === 'Run')
                        action.play();
                        console.log("Playing animation:", gltf.animations[0].name);
                    } else {
                        console.log("No animations found in the model.");
                    }

                    // Call the callback function provided to signal loading is complete
                    if (onLoadCallback) {
                        onLoadCallback();
                    }
                },
                // onProgress: Optional progress callback
                (xhr) => {
                    // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // onError: Error callback
                (error) => {
                    console.error('Error loading player model:', error);
                    // Maybe fall back to the capsule or show an error message
                    showStartMessage("Error loading model. Please refresh.", true); // Show permanent error
                    gameState = 'error'; // Prevent starting
                }
            );
        }
        // --- CHANGE END ---


        // --- Game Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // --- CHANGE START ---
            // Update player animation mixer regardless of game state if it exists
            if (playerMixer) {
                playerMixer.update(deltaTime);
            }
            // --- CHANGE END ---

             if (gameState === 'playing') {
                // Update Score
                score += deltaTime;
                updateScoreDisplay();

                 // Increase game speed gradually
                 if (gameSpeed < MAX_GAME_SPEED) {
                     gameSpeed += SPEED_INCREASE_RATE * deltaTime;
                 }

                 // Handle Player Movement & Physics
                updatePlayerPosition(deltaTime);
                handleJump(deltaTime);

                // Handle Obstacles
                updateObstacles(deltaTime);
                spawnObstacles(deltaTime);
                checkCollisions(); // Uses the updated playerBoundingBox
            }

            renderer.render(scene, camera);
        }

        // --- Player Logic ---
         function updatePlayerPosition(deltaTime) {
            if (!player) return; // Don't update if player model isn't loaded yet

            // Smooth lane transition
            const targetX = LANES[currentLane];
            const lerpFactor = 10 * deltaTime;
            player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, lerpFactor);

            // Keep player Z position relatively constant relative to camera
            player.position.z = camera.position.z - 5;

            // --- CHANGE START ---
            // Update player bounding box based on the model's current world position/rotation/scale
            // playerBoundingBox.setFromObject(player, true); // Update each frame - can be slightly expensive
            // Optimization: If scale/rotation don't change, just copy position:
             playerBoundingBox.copy(player.userData.originalBox || playerBoundingBox); // Assumes an initial calculation
             playerBoundingBox.translate(player.position); // More efficient if model doesn't rotate/scale during gameplay

             // More robust: Recalculate fully if needed, less frequently if possible
             if (player) {
                 playerBoundingBox.setFromObject(player, true); // Calculate based on current state
                 // Optional: Shrink the box slightly for more forgiving collisions
                 playerBoundingBox.expandByScalar(-0.1);
             }
            // --- CHANGE END ---
        }

        function handleJump(deltaTime) {
             if (!player) return;
             // --- CHANGE START ---
             const groundLevel = playerHeight / 2; // Use calculated height
             // --- CHANGE END ---

             if (isJumping) {
                playerVelocityY -= GRAVITY * deltaTime;
                player.position.y += playerVelocityY * deltaTime;

                 if (player.position.y <= groundLevel) {
                    player.position.y = groundLevel;
                    isJumping = false;
                    playerVelocityY = 0;
                }
            }
        }

         function jump() {
             // --- CHANGE START ---
            // Allow jump only when playing and player exists
            if (!isJumping && gameState === 'playing' && player) {
            // --- CHANGE END ---
                isJumping = true;
                playerVelocityY = JUMP_VELOCITY;
            }
        }

         function moveLane(direction) { // direction is -1 for left, 1 for right
            if (gameState !== 'playing' || !player) return; // Check player exists
            const targetLane = currentLane + direction;
            if (targetLane >= 0 && targetLane < LANES.length) {
                currentLane = targetLane;
            }
        }

        // --- Obstacle Logic ---
        // createObstacle, updateObstacles, spawnObstacles, calculateNextSpawnInterval remain the same
        // But they create their own bounding boxes: obstacle.userData.boundingBox = new THREE.Box3(); obstacle.userData.boundingBox.setFromObject(obstacle);

        function createObstacle() {
            const obstacleTypes = [
                { type: 'trashcan', geometry: new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16), color: 0x888888 }, // Grey
                { type: 'cactus', geometry: new THREE.BoxGeometry(0.8, 1.5, 0.8), color: 0x228B22 }, // Forest Green
                { type: 'lizard', geometry: new THREE.BoxGeometry(1.0, 0.3, 0.4), color: 0x90EE90 }, // Light Green
                { type: 'dog', geometry: new THREE.CapsuleGeometry(0.6, 1.0, 4, 8), color: 0x8B4513 }, // Saddle Brown
                { type: 'cat', geometry: new THREE.CapsuleGeometry(0.4, 0.7, 4, 8), color: 0xFFD700 }, // Gold
            ];

             const data = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const material = new THREE.MeshStandardMaterial({ color: data.color });
            const obstacle = new THREE.Mesh(data.geometry, material);

             obstacle.castShadow = true;
            obstacle.receiveShadow = true;

            const laneIndex = Math.floor(Math.random() * LANES.length);
            obstacle.position.x = LANES[laneIndex];
            obstacle.position.z = OBSTACLE_SPAWN_Z;

             // Adjust Y position based on geometry center (same as before)
            if (data.geometry.type === 'BoxGeometry') {
                obstacle.position.y = data.geometry.parameters.height / 2;
            } else if (data.geometry.type === 'CylinderGeometry') {
                obstacle.position.y = data.geometry.parameters.height / 2;
            } else if (data.geometry.type === 'CapsuleGeometry') {
                 obstacle.position.y = data.geometry.parameters.length / 2 + data.geometry.parameters.radius;
             } else {
                 obstacle.position.y = 0.5; // Default
             }

            obstacle.userData.boundingBox = new THREE.Box3(); // Create bounding box
            scene.add(obstacle);
            obstacle.userData.boundingBox.setFromObject(obstacle); // Calculate AFTER adding to scene
            obstacles.push(obstacle);
        }

        function updateObstacles(deltaTime) {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += gameSpeed * deltaTime;

                // Update bounding box position simply by translating
                obstacle.userData.boundingBox.setFromObject(obstacle); // Recalculate if needed, simple translation might drift if obstacle rotates/scales

                if (obstacle.position.z > OBSTACLE_DESPAWN_Z) {
                    scene.remove(obstacle);
                    obstacle.geometry.dispose();
                    obstacle.material.dispose();
                    obstacles.splice(i, 1);
                }
            }
        }
         function spawnObstacles(deltaTime) {
            timeSinceLastSpawn += deltaTime;
            if (timeSinceLastSpawn > nextSpawnInterval) {
                createObstacle();
                timeSinceLastSpawn = 0;
                nextSpawnInterval = calculateNextSpawnInterval();
            }
        }

         function calculateNextSpawnInterval() {
            const speedFactor = Math.max(0.5, 1 - (gameSpeed / (MAX_GAME_SPEED * 1.5)));
            const min = OBSTACLE_SPAWN_INTERVAL_MIN * speedFactor;
            const max = OBSTACLE_SPAWN_INTERVAL_MAX * speedFactor;
            return Math.random() * (max - min) + min;
        }

        // --- Collision Detection ---
        function checkCollisions() {
             if (!player || !playerBoundingBox) return; // Don't check if player isn't ready

            for (const obstacle of obstacles) {
                 if (playerBoundingBox.intersectsBox(obstacle.userData.boundingBox)) {
                    triggerGameOver();
                    return;
                }
            }
        }


        // --- Game State Management ---
        function startGame() {
            // --- CHANGE START ---
            // Only start if assets are loaded and we are in waiting state
            if (assetsLoaded && gameState === 'waiting') {
                 gameState = 'playing';
                 hideStartMessage();
                 gameOverScreen.style.display = 'none';
                 // Animation loop is already running
                 if (clock.running === false) clock.start(); // Resume clock if paused
            }
            // --- CHANGE END ---
        }

        function triggerGameOver() {
            if (gameState === 'playing') {
                gameState = 'gameOver';
                 // Keep animation loop running for game over screen background
                 // Optional: Stop clock if score shouldn't increment further?
                 // clock.stop();

                 saveHighScore();
                 updateHighScoreDisplay();

                 finalScoreElement.textContent = `Your Score: ${Math.floor(score)}`;
                sessionHighScoreElement.textContent = `High Score: ${highScore}`;
                gameOverScreen.style.display = 'flex';
            }
        }

        function resetGame() {
             if (!player) return; // Cannot reset if player never loaded

             // Stop the current animation loop? No, keep it running for UI/background.

            // Clear obstacles
            obstacles.forEach(obstacle => {
                scene.remove(obstacle);
                obstacle.geometry.dispose();
                obstacle.material.dispose();
            });
            obstacles = [];

            // Reset player
            player.position.copy(PLAYER_START_POS);
            // --- CHANGE START ---
            player.position.y = playerHeight / 2; // Use calculated height
            // Recalculate bounding box after position reset
            playerBoundingBox.setFromObject(player, true);
            // --- CHANGE END ---
            currentLane = 1;
            isJumping = false;
            playerVelocityY = 0;

            // --- CHANGE START ---
            // Reset animation? Optional, might depend on desired effect
            // if (playerMixer) {
            //    playerMixer.setTime(0); // Reset animation time
            //    // Ensure the correct animation is playing if needed
            // }
            // --- CHANGE END ---

            // Reset game variables
            score = 0;
            gameSpeed = INITIAL_GAME_SPEED;
            timeSinceLastSpawn = 0;
            nextSpawnInterval = calculateNextSpawnInterval();
            updateScoreDisplay();

            // Hide game over screen
            gameOverScreen.style.display = 'none';

             // Set state to waiting and show start message
             // --- CHANGE START ---
            gameState = 'waiting'; // Go back to waiting state
            showStartMessage("Press Any Key or Click to Start");
            // --- CHANGE END ---

             if (clock.running === false) clock.start(); // Ensure clock is running
             // animate() is already running
        }


        // --- UI & Scoring ---
        function updateScoreDisplay() {
            scoreElement.textContent = `Score: ${Math.floor(score)}`;
        }

        function updateHighScoreDisplay() {
            highScoreElement.textContent = `High Score: ${highScore}`;
        }

        // --- CHANGE START ---
        function showStartMessage(message = "Loading...", permanent = false) {
            startMessage.textContent = message;
            startMessage.style.display = 'block';
             // Allow interaction only if not loading or permanent error
            startMessage.style.pointerEvents = (gameState === 'loading' || permanent) ? 'none' : 'all';
        }
        // --- CHANGE END ---
        function hideStartMessage() {
            startMessage.style.display = 'none';
        }

        // --- Local Storage (same as before) ---
        function saveHighScore() {
            if (Math.floor(score) > highScore) {
                highScore = Math.floor(score);
                try {
                    localStorage.setItem(HIGH_SCORE_KEY, highScore.toString());
                } catch (e) {
                    console.error("Could not save high score to local storage:", e);
                }
            }
        }

        function loadHighScore() {
            try {
                const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
                if (storedHighScore !== null) {
                    highScore = parseInt(storedHighScore, 10) || 0;
                }
            } catch (e) {
                console.error("Could not load high score from local storage:", e);
                highScore = 0;
            }
        }

        // --- Event Handlers ---
        function onWindowResize() {
            const newWidth = gameContainer.clientWidth;
            const newHeight = gameContainer.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        let gameStartedOnce = false; // This flag is still useful
        function startGameOnce() {
             // --- CHANGE START ---
             // Only allow starting if assets are loaded and we are in the waiting state
             if (!gameStartedOnce && assetsLoaded && gameState === 'waiting') {
                 gameStartedOnce = true; // Set flag even if startGame doesn't run immediately
                 startGame();
                 // Remove listeners only if game actually started
                 // window.removeEventListener('keydown', startGameOnce); // Keep keydown for movement
                 // window.removeEventListener('mousedown', startGameOnce); // Keep mousedown potentially?
            }
             // --- CHANGE END ---
         }


        function onKeyDown(event) {
            // Allow starting the game with any key IF assets are loaded and waiting
            if (!gameStartedOnce && assetsLoaded && gameState === 'waiting') {
                startGameOnce();
                return; // Don't process movement on the first start key press
            }

             // Process movement/jump only when playing
             if (gameState !== 'playing') return;

            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    moveLane(-1);
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveLane(1);
                    break;
                case 'Space':
                case 'ArrowUp':
                case 'KeyW':
                    jump();
                    break;
            }
        }

        // --- Start the experience ---
        init(); // Call init to start loading etc.

    </script>
</body>
</html>