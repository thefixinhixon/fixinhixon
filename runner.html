<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Runner</title>
    <style>
        /* CSS remains the same (full screen setup) */
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: 'Arial', sans-serif; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #uiContainer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; pointer-events: none; font-size: 24px; text-shadow: 1px 1px 2px black; }
        #score { } #highScoreDisplay { }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 28px; pointer-events: all; }
        #gameOverScreen h2 { margin-bottom: 15px; } #finalScore, #sessionHighScore { margin-bottom: 20px; }
        #restartButton { padding: 15px 30px; font-size: 20px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; transition: background-color 0.3s ease; }
        #restartButton:hover { background-color: #45a049; }
        #startMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; text-align: center; background-color: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="score">Score: 0</div>
            <div id="highScoreDisplay">High Score: 0</div>
        </div>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <div id="finalScore">Your Score: 0</div>
            <div id="sessionHighScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
         <div id="startMessage">Loading Assets...</div>
    </div>

    <!-- Import map -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        const LANE_WIDTH = 2.5;
        const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const PLAYER_START_POS = new THREE.Vector3(0, 0, 10);
        const PLAYER_RUN_MODEL_PATH = 'raccoon.glb';
        const PLAYER_JUMP_MODEL_PATH = 'raccoon_jump.glb';
        const PLAYER_MODEL_SCALE = 0.02; // Adjusted scale
        const ANIMATION_FADE_TIME = 0.2;
        const INITIAL_GAME_SPEED = 8;
        const MAX_GAME_SPEED = 30;
        const SPEED_INCREASE_RATE = 0.1;
        const OBSTACLE_SPAWN_Z = -50;
        const OBSTACLE_DESPAWN_Z = 15;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 0.8;
        const OBSTACLE_SPAWN_INTERVAL_MAX = 2.0;
        const JUMP_VELOCITY = 10;
        const GRAVITY = 25;
        const HIGH_SCORE_KEY = 'raccoonRunnerHighScore';

        // --- CHANGE START: Texture Config ---
        const GROUND_TEXTURE_PATHS = [
            'ground1.jpg',
            'ground2.jpg',
            'ground3.jpg',
            'ground4.jpg'
        ];
        const SKY_TEXTURE_PATH = 'sky.jpg';
        const GROUND_TEXTURE_REPEAT = 10; // How many times ground texture repeats width/length wise on visible plane section
        const GROUND_FADE_INTERVAL = 30.0; // Seconds between fades
        const GROUND_FADE_DURATION = 1.5; // Seconds the fade takes
        // --- CHANGE END ---

        // --- Game State ---
        let scene, camera, renderer, clock, player, ground; // Added ground variable
        let gameSpeed = INITIAL_GAME_SPEED;
        let obstacles = [];
        let currentLane = 1;
        let score = 0;
        let highScore = 0;
        let timeSinceLastSpawn = 0;
        let nextSpawnInterval = calculateNextSpawnInterval();
        let isJumping = false;
        let playerVelocityY = 0;
        let gameState = 'loading';
        let animationFrameId = null;
        let playerMixer = null;
        let playerAnimations = {};
        let runAction = null;
        let jumpAction = null;
        let playerBoundingBox = new THREE.Box3();
        let playerHeight = 1;
        let assetsLoaded = false;
        let gameStartedOnce = false;

        // --- CHANGE START: Texture State ---
        let textureLoader;
        let groundMaterials = []; // Array for the two ground materials
        let currentGroundTextureIndex = 0;
        let visibleMaterialIndex = 0; // 0 or 1, indicates which material in groundMaterials is opaque
        let timeSinceLastGroundFade = 0;
        let isFadingGround = false;
        let groundFadeTimer = 0;
        let nextGroundTexture = null; // Preload the next texture
        // --- CHANGE END ---

        // --- DOM Elements (remain the same) ---
        const gameCanvas = document.getElementById('gameCanvas');
        // ... other DOM elements ...
         const startMessage = document.getElementById('startMessage');

        // --- Initialization ---
        function init() {
            textureLoader = new THREE.TextureLoader(); // Init texture loader

            // Basic Setup
            scene = new THREE.Scene();
            // scene.background will be set after sky texture loads
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60); // Fog color might need adjustment based on sky
            clock = new THREE.Clock();

            // Camera & Renderer (remain the same)
            const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 4, 15); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lights (remain the same)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7); directionalLight.castShadow = true;
            // Shadow settings (remain the same)
            directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // --- CHANGE START: Ground Setup ---
            const groundGeometry = new THREE.PlaneGeometry(40, 150); // Wider plane might be good

            // Create TWO materials for fading
            groundMaterials[0] = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA, // Fallback color
                side: THREE.DoubleSide,
                // Map will be set during asset loading
            });
            groundMaterials[1] = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                side: THREE.DoubleSide,
                transparent: true, // Enable transparency for the second material
                opacity: 0,      // Start fully transparent
                // Map will be set during asset loading/fading
            });

            ground = new THREE.Mesh(groundGeometry, groundMaterials); // Use the array of materials
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
            // --- CHANGE END ---

            // Load High Score
            loadHighScore();
            updateHighScoreDisplay();

            // Load all assets (Models, Sky, Initial Ground)
            loadAssets().then(() => {
                assetsLoaded = true;
                gameState = 'waiting';
                showStartMessage("Press Any Key or Click to Start");
                window.addEventListener('keydown', startGameOnce);
                window.addEventListener('mousedown', startGameOnce);
                console.log("Assets loaded, ready to start.");
                 playAnimation('run'); // Start with the run animation
            }).catch(error => {
                console.error("Failed to load assets:", error);
                showStartMessage("Error loading assets. Please refresh.", true);
                gameState = 'error';
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            restartButton.addEventListener('click', resetGame);

            // Start the animation loop
            animate();
        }

        // --- Asset Loading ---
        function loadAssets() {
            const gltfLoader = new GLTFLoader();
            const runPromise = gltfLoader.loadAsync(PLAYER_RUN_MODEL_PATH);
            const jumpPromise = gltfLoader.loadAsync(PLAYER_JUMP_MODEL_PATH);

            // --- CHANGE START: Load Textures ---
            const skyPromise = textureLoader.loadAsync(SKY_TEXTURE_PATH);

            // Choose initial ground texture randomly
            currentGroundTextureIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length);
            const initialGroundPath = GROUND_TEXTURE_PATHS[currentGroundTextureIndex];
            const groundPromise = textureLoader.loadAsync(initialGroundPath);
             // --- CHANGE END ---

            // Wait for models and essential textures
            return Promise.all([runPromise, jumpPromise, skyPromise, groundPromise])
                .then(([gltfRun, gltfJump, skyTexture, initialGroundTexture]) => {

                // --- Player Model Setup (using refined Y position) ---
                player = gltfRun.scene;
                player.scale.set(PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE);
                player.rotation.y = Math.PI;
                player.position.set(PLAYER_START_POS.x, 0, PLAYER_START_POS.z); // Temp Y
                player.traverse(child => { if (child.isMesh) child.castShadow = true; });
                scene.add(player); // Add before box calculation
                playerBoundingBox.setFromObject(player, true);
                const playerSize = new THREE.Vector3(); playerBoundingBox.getSize(playerSize);
                playerHeight = playerSize.y;
                const minY = playerBoundingBox.min.y;
                const groundOffset = -minY;
                player.position.y = groundOffset; // Set final Y
                player.userData.groundY = groundOffset; // Store ground level
                playerBoundingBox.setFromObject(player, true); // Recalculate box
                console.log("Player model processed. GroundY:", player.userData.groundY, "Height:", playerHeight);

                // --- Animation Setup (remains the same) ---
                playerMixer = new THREE.AnimationMixer(player);
                if (gltfRun.animations && gltfRun.animations.length > 0) { playerAnimations['run'] = gltfRun.animations[0]; runAction = playerMixer.clipAction(playerAnimations['run']); runAction.setLoop(THREE.LoopRepeat); } else { console.warn("No run anim"); }
                if (gltfJump.animations && gltfJump.animations.length > 0) { playerAnimations['jump'] = gltfJump.animations[0]; jumpAction = playerMixer.clipAction(playerAnimations['jump']); jumpAction.setLoop(THREE.LoopOnce); jumpAction.clampWhenFinished = true;} else { console.warn("No jump anim"); }
                if (!runAction) { throw new Error("Run animation action failed."); }

                // --- CHANGE START: Apply Textures ---
                // Sky Texture
                skyTexture.mapping = THREE.EquirectangularReflectionMapping; // Crucial for sky
                scene.background = skyTexture;
                scene.environment = skyTexture; // Optional: Use for environment lighting

                // Ground Texture (Initial)
                initialGroundTexture.wrapS = THREE.RepeatWrapping;
                initialGroundTexture.wrapT = THREE.RepeatWrapping;
                initialGroundTexture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40)); // Adjust repeat based on plane aspect ratio
                groundMaterials[visibleMaterialIndex].map = initialGroundTexture; // Apply to the initially visible material
                groundMaterials[visibleMaterialIndex].needsUpdate = true;

                // Preload the *next* ground texture (for the first fade)
                preloadNextGroundTexture();
                // --- CHANGE END ---
            });
        }

        // --- CHANGE START: Ground Texture Fading Logic ---
        function preloadNextGroundTexture() {
            const nextIndex = (currentGroundTextureIndex + 1) % GROUND_TEXTURE_PATHS.length;
            const nextPath = GROUND_TEXTURE_PATHS[nextIndex];
            textureLoader.load(nextPath, (texture) => {
                 texture.wrapS = THREE.RepeatWrapping;
                 texture.wrapT = THREE.RepeatWrapping;
                 texture.repeat.copy(groundMaterials[visibleMaterialIndex].map.repeat); // Use same repeat settings
                 nextGroundTexture = texture; // Store preloaded texture
                 console.log("Preloaded next ground texture:", nextPath);
            });
        }

        function startGroundFade() {
            if (!nextGroundTexture || isFadingGround) return; // Don't fade if next texture isn't ready or already fading

            isFadingGround = true;
            groundFadeTimer = 0;

            const fadingInMaterialIndex = 1 - visibleMaterialIndex; // The currently invisible material

            // Apply the preloaded texture to the material that will fade in
            groundMaterials[fadingInMaterialIndex].map = nextGroundTexture;
            groundMaterials[fadingInMaterialIndex].opacity = 0; // Ensure it starts transparent
            groundMaterials[fadingInMaterialIndex].needsUpdate = true;

            nextGroundTexture = null; // Clear the preloaded texture slot

             console.log("Starting ground fade to index:", (currentGroundTextureIndex + 1) % GROUND_TEXTURE_PATHS.length);
        }

        function updateGroundFade(deltaTime) {
            if (!isFadingGround) return;

            groundFadeTimer += deltaTime;
            let fadeProgress = groundFadeTimer / GROUND_FADE_DURATION;
            fadeProgress = Math.min(fadeProgress, 1.0); // Clamp to 1

            const fadingInMaterialIndex = 1 - visibleMaterialIndex;
            const fadingOutMaterialIndex = visibleMaterialIndex;

            groundMaterials[fadingInMaterialIndex].opacity = fadeProgress;
            groundMaterials[fadingOutMaterialIndex].opacity = 1.0 - fadeProgress;

            // Fade complete
            if (fadeProgress >= 1.0) {
                isFadingGround = false;
                groundFadeTimer = 0;
                timeSinceLastGroundFade = 0; // Reset interval timer

                // Update current texture index
                currentGroundTextureIndex = (currentGroundTextureIndex + 1) % GROUND_TEXTURE_PATHS.length;
                // Update which material is now the fully visible one
                visibleMaterialIndex = fadingInMaterialIndex;

                // Fully set opacities for clarity
                groundMaterials[visibleMaterialIndex].opacity = 1.0;
                groundMaterials[1 - visibleMaterialIndex].opacity = 0.0; // Ensure other is fully transparent

                console.log("Ground fade complete. New visible index:", currentGroundTextureIndex);

                // Preload the *next* texture for the subsequent fade
                preloadNextGroundTexture();
            }
        }
        // --- CHANGE END ---


        // Helper function to play animations (remains the same)
        function playAnimation(name) { /* ... same as before ... */ }

        // --- Game Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (playerMixer) playerMixer.update(deltaTime); // Update animations

             if (gameState === 'playing') {
                score += deltaTime;
                updateScoreDisplay();
                 if (gameSpeed < MAX_GAME_SPEED) gameSpeed += SPEED_INCREASE_RATE * deltaTime;
                updatePlayerPosition(deltaTime);
                handleJump(deltaTime);
                updateObstacles(deltaTime);
                spawnObstacles(deltaTime);
                checkCollisions();

                // --- CHANGE START: Update Ground Texture ---
                timeSinceLastGroundFade += deltaTime;

                // Trigger fade periodically
                if (!isFadingGround && timeSinceLastGroundFade > GROUND_FADE_INTERVAL) {
                    startGroundFade();
                }

                // Process active fade
                updateGroundFade(deltaTime);

                 // Update texture offset for movement illusion
                 // Apply to both materials - simpler than checking which is visible during fade
                 const textureOffsetY = (clock.elapsedTime * gameSpeed * 0.05) % 1; // Adjust multiplier for desired speed
                 if (groundMaterials[0].map) groundMaterials[0].map.offset.y = textureOffsetY;
                 if (groundMaterials[1].map) groundMaterials[1].map.offset.y = textureOffsetY;
                // --- CHANGE END ---
            }

            renderer.render(scene, camera);
        }

        // --- Player Logic (updatePlayerPosition, handleJump, jump, moveLane) ---
        // Remains unchanged (using player.userData.groundY)
         function updatePlayerPosition(deltaTime) { /* ... same ... */ }
         function handleJump(deltaTime) { /* ... same ... */ }
         function jump() { /* ... same ... */ }
         function moveLane(direction) { /* ... same ... */ }

        // --- Obstacle Logic (create, update, spawn, calculateInterval) ---
        // Remains unchanged
        function createObstacle() { /* ... same ... */ }
        function updateObstacles(deltaTime) { /* ... same ... */ }
        function spawnObstacles(deltaTime) { /* ... same ... */ }
        function calculateNextSpawnInterval() { /* ... same ... */ }

        // --- Collision Detection (checkCollisions) ---
        // Remains unchanged
        function checkCollisions() { /* ... same ... */ }

        // --- Game State Management (startGame, triggerGameOver, resetGame) ---
        function startGame() { /* ... same ... */ }
        function triggerGameOver() { /* ... same ... */ }
        function resetGame() {
            // --- CHANGE START: Reset Texture State ---
            isFadingGround = false;
            groundFadeTimer = 0;
            timeSinceLastGroundFade = 0; // Reset fade timer
            // Reset ground materials to initial random texture state
            currentGroundTextureIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length);
            const initialGroundPath = GROUND_TEXTURE_PATHS[currentGroundTextureIndex];
            textureLoader.load(initialGroundPath, (texture) => {
                 texture.wrapS = THREE.RepeatWrapping;
                 texture.wrapT = THREE.RepeatWrapping;
                 // Ensure repeat settings are reapplied correctly
                 texture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40));

                 visibleMaterialIndex = 0; // Reset visible to material 0
                 groundMaterials[0].map = texture;
                 groundMaterials[0].opacity = 1.0;
                 groundMaterials[0].needsUpdate = true;
                 groundMaterials[1].map = null; // Clear other material map initially
                 groundMaterials[1].opacity = 0.0;
                 groundMaterials[1].needsUpdate = true;
                 // Preload next texture after reset
                 preloadNextGroundTexture();
            });
            // --- CHANGE END ---

            if (!player || player.userData.groundY === undefined) return;
            obstacles.forEach(obstacle => { scene.remove(obstacle); obstacle.geometry.dispose(); obstacle.material.dispose(); });
            obstacles = [];
            player.position.copy(PLAYER_START_POS); player.position.y = player.userData.groundY;
            playerBoundingBox.setFromObject(player, true); currentLane = 1; isJumping = false; playerVelocityY = 0;
            score = 0; gameSpeed = INITIAL_GAME_SPEED; timeSinceLastSpawn = 0; nextSpawnInterval = calculateNextSpawnInterval();
            updateScoreDisplay(); gameOverScreen.style.display = 'none'; gameState = 'waiting';
            gameStartedOnce = false; showStartMessage("Press Any Key or Click to Start");
            if (playerMixer) { if(jumpAction && jumpAction.isRunning()) jumpAction.stop(); if(runAction) runAction.reset().play(); }
            if (clock.running === false) clock.start();
        }

        // --- UI & Scoring (remain the same) ---
        function updateScoreDisplay() { /* ... same ... */ }
        function updateHighScoreDisplay() { /* ... same ... */ }
        function showStartMessage(message = "Loading...", permanent = false) { /* ... same ... */ }
        function hideStartMessage() { /* ... same ... */ }

        // --- Local Storage (remain the same) ---
        function saveHighScore() { /* ... same ... */ }
        function loadHighScore() { /* ... same ... */ }

        // --- Event Handlers (remain the same) ---
        function onWindowResize() { /* ... same ... */ }
        function startGameOnce() { /* ... same ... */ }
        function onKeyDown(event) { /* ... same ... */ }

        // --- Start the experience ---
        init();

    </script>
</body>
</html>
