<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Runner</title>
    <style>
        /* CSS remains the same */
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: 'Arial', sans-serif; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #uiContainer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; pointer-events: none; font-size: 24px; text-shadow: 1px 1px 2px black; }
        #score { } #highScoreDisplay { }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 28px; pointer-events: all; }
        #gameOverScreen h2 { margin-bottom: 15px; } #finalScore, #sessionHighScore { margin-bottom: 20px; }
        #restartButton { padding: 15px 30px; font-size: 20px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; transition: background-color 0.3s ease; }
        #restartButton:hover { background-color: #45a049; }
        #startMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; text-align: center; background-color: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <!-- HTML Structure -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="score">Score: 0</div>
            <div id="highScoreDisplay">High Score: 0</div>
        </div>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <div id="finalScore">Your Score: 0</div>
            <div id="sessionHighScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
         <div id="startMessage">Loading Assets...</div>
    </div>

    <!-- Import map -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>

    <!-- JavaScript Module -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        const LANE_WIDTH = 2.5; const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const PLAYER_START_POS = new THREE.Vector3(0, 0, 10);
        const PLAYER_RUN_MODEL_PATH = 'raccoon.glb'; const PLAYER_JUMP_MODEL_PATH = 'raccoon_jump.glb';
        const PLAYER_MODEL_SCALE = 0.02; const ANIMATION_FADE_TIME = 0.2;
        const INITIAL_GAME_SPEED = 8; const MAX_GAME_SPEED = 30; const SPEED_INCREASE_RATE = 0.1;
        const OBSTACLE_SPAWN_Z = -50; const OBSTACLE_DESPAWN_Z = 15;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 0.8; const OBSTACLE_SPAWN_INTERVAL_MAX = 2.0;
        const JUMP_VELOCITY = 10; const GRAVITY = 25; const HIGH_SCORE_KEY = 'raccoonRunnerHighScore';
        const GROUND_TEXTURE_PATHS = [ 'ground1.jpg', 'ground2.jpg', 'ground3.jpg', 'ground4.jpg' ];
        const SKY_TEXTURE_PATH = 'sky.jpg'; const GROUND_TEXTURE_REPEAT = 10;
        const TRASHCAN_MODEL_PATH = 'trashcan.glb'; const CACTUS_MODEL_PATH = 'cactus.glb';
        // --- MODIFIED SCALES ---
        const TRASHCAN_SCALE = 0.015; // Drastically reduced to be jumpable
        const CACTUS_SCALE = 0.035;   // Drastically reduced, but taller than trashcan (dodge)
        // --- END MODIFIED SCALES ---
        const GROUND_CLIP_ADJUSTMENT = 0.1; // << INCREASED VALUE for clipping

        // --- Game State ---
        let scene, camera, renderer, clock, player, ground;
        let gameSpeed = INITIAL_GAME_SPEED; let obstacles = []; let currentLane = 1;
        let score = 0; let highScore = 0; let timeSinceLastSpawn = 0; let nextSpawnInterval = calculateNextSpawnInterval();
        let isJumping = false; let playerVelocityY = 0; let gameState = 'loading'; let animationFrameId = null;
        let playerMixer = null; let playerAnimations = {}; let runAction = null; let jumpAction = null;
        let playerBoundingBox = new THREE.Box3(); let playerHeight = 1; // playerHeight is calculated later
        let assetsLoaded = false; let gameStartedOnce = false;
        let textureLoader; let gltfLoader;
        let cachedTrashcanModel = null; // Variables to hold loaded models
        let cachedCactusModel = null;

        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas'); const gameContainer = document.getElementById('gameContainer');
        const scoreElement = document.getElementById('score'); const highScoreElement = document.getElementById('highScoreDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen'); const finalScoreElement = document.getElementById('finalScore');
        const sessionHighScoreElement = document.getElementById('sessionHighScore'); const restartButton = document.getElementById('restartButton');
        const startMessage = document.getElementById('startMessage');

        // --- Initialization ---
        function init() {
            console.log("init: Started.");
            textureLoader = new THREE.TextureLoader(); gltfLoader = new GLTFLoader();
            scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x87CEEB, 10, 60); clock = new THREE.Clock();
            const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000); camera.position.set(0, 4, 15); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true }); renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(5, 10, 7); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20; directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20; scene.add(directionalLight);
            const groundGeometry = new THREE.PlaneGeometry(40, 150);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, side: THREE.DoubleSide, map: null });
            ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.position.y = 0; ground.receiveShadow = true; scene.add(ground);
            console.log("init: Ground mesh created with single material.");
            loadHighScore(); updateHighScoreDisplay();
            console.log("init: Calling loadAssets()...");
            loadAssets().then(() => {
                console.log("init: loadAssets() promise resolved successfully.");
                assetsLoaded = true; gameState = 'waiting';
                showStartMessage("Press Any Key or Click to Start");
                window.addEventListener('keydown', startGameOnce); window.addEventListener('mousedown', startGameOnce);
                console.log("init: Added start listeners. Game ready state set.");
                playAnimation('run');
            }).catch(error => {
                console.error("init: CRITICAL ERROR during asset loading:", error);
                showStartMessage("Error loading assets. Please refresh.", true); gameState = 'error';
            });
            window.addEventListener('resize', onWindowResize); document.addEventListener('keydown', onKeyDown); restartButton.addEventListener('click', resetGame);
            console.log("init: Starting animation loop..."); animate(); console.log("init: Function finished.");
        }

        // --- Asset Loading (Obstacle Models Re-enabled) ---
        function loadAssets() {
            console.log("loadAssets: Starting...");
            const runPromise = gltfLoader.loadAsync(PLAYER_RUN_MODEL_PATH);
            const jumpPromise = gltfLoader.loadAsync(PLAYER_JUMP_MODEL_PATH);
            const skyPromise = textureLoader.loadAsync(SKY_TEXTURE_PATH);
            const groundLoadPromise = new Promise((resolve, reject) => {
                const initialGroundIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length);
                const initialGroundPath = GROUND_TEXTURE_PATHS[initialGroundIndex];
                console.log("loadAssets: Loading initial ground:", initialGroundPath);
                textureLoader.load( initialGroundPath,
                    (texture) => { console.log("loadAssets: Initial ground texture loaded:", initialGroundPath); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40)); ground.material.map = texture; ground.material.needsUpdate = true; console.log("loadAssets: Initial ground texture applied."); resolve(); },
                    undefined, (errorEvent) => { console.error("loadAssets: FAILED loading ground texture:", initialGroundPath, errorEvent); reject(new Error(`Failed ground texture: ${initialGroundPath}`)); } ); });

            // --- Obstacle loading re-enabled ---
            console.log("loadAssets: Loading obstacle models...");
            const trashcanPromise = gltfLoader.loadAsync(TRASHCAN_MODEL_PATH);
            const cactusPromise = gltfLoader.loadAsync(CACTUS_MODEL_PATH);
            // ---

            console.log("loadAssets: Promises created, awaiting Promise.all...");
            // Add obstacle promises back to Promise.all
            return Promise.all([runPromise, jumpPromise, skyPromise, groundLoadPromise, trashcanPromise, cactusPromise])
                .then(([gltfRun, gltfJump, skyTexture, /* ground loaded */, gltfTrashcan, gltfCactus]) => { // Add results to destructuring
                    console.log("loadAssets: Promise.all resolved.");

                    // --- Obstacle model caching re-enabled ---
                    console.log("loadAssets: Caching obstacle models...");
                    cachedTrashcanModel = gltfTrashcan.scene;
                    cachedCactusModel = gltfCactus.scene;
                    // Optional: Pre-configure shadows etc. on cached models if needed
                    // cachedTrashcanModel.traverse(child => { if (child.isMesh) child.castShadow = true; });
                    // cachedCactusModel.traverse(child => { if (child.isMesh) child.castShadow = true; });
                    console.log("loadAssets: Obstacle models cached.");
                    // ---

                    // Player Model Setup + Clipping Adjustment
                    console.log("loadAssets: Setting up player model...");
                    player = gltfRun.scene; player.scale.set(PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE); player.rotation.y = Math.PI; player.position.set(PLAYER_START_POS.x, 0, PLAYER_START_POS.z); player.traverse(child => { if (child.isMesh) child.castShadow = true; }); scene.add(player);
                    playerBoundingBox.setFromObject(player, true); const ps = new THREE.Vector3(); playerBoundingBox.getSize(ps); playerHeight = ps.y; // Set player height here based on scaled model
                    const mnY = playerBoundingBox.min.y;
                    let groundOffset = -mnY + GROUND_CLIP_ADJUSTMENT; // Apply increased adjustment
                    console.log(`loadAssets: Calculated groundOffset: ${-mnY}, Adjusted to: ${groundOffset}`);
                    player.position.y = groundOffset; player.userData.groundY = groundOffset;
                    playerBoundingBox.setFromObject(player, true); // Recalculate box after position adjust
                    console.log("loadAssets: Player model setup complete. GroundY:", player.userData.groundY, "Player Scaled Height:", playerHeight);

                    // Animation Setup
                    console.log("loadAssets: Setting up animations...");
                    playerMixer = new THREE.AnimationMixer(player); if (gltfRun.animations && gltfRun.animations.length > 0) { playerAnimations['run'] = gltfRun.animations[0]; runAction = playerMixer.clipAction(playerAnimations['run']); runAction.setLoop(THREE.LoopRepeat); } else { console.warn("No run anim"); } if (gltfJump.animations && gltfJump.animations.length > 0) { playerAnimations['jump'] = gltfJump.animations[0]; jumpAction = playerMixer.clipAction(playerAnimations['jump']); jumpAction.setLoop(THREE.LoopOnce); jumpAction.clampWhenFinished = true;} else { console.warn("No jump anim"); } if (!runAction) { console.error("CRITICAL: Run animation action failed."); }
                    console.log("loadAssets: Animation setup complete.");

                    // Apply Sky Texture
                    console.log("loadAssets: Applying sky texture...");
                    skyTexture.mapping = THREE.EquirectangularReflectionMapping; scene.background = skyTexture; scene.environment = skyTexture;
                    console.log("loadAssets: Sky texture applied.");

                    console.log("loadAssets: .then() block finished successfully.");
                }).catch(error => { console.error("loadAssets: Error within Promise.all or .then():", error); throw error; });
        }

        // --- Helper function to play animations ---
        function playAnimation(name) { if (!playerMixer || !assetsLoaded) return; const actionToPlay = name === 'jump' ? jumpAction : runAction; if (!actionToPlay) { console.warn(`Animation action "${name}" not found.`); return; } const currentAction = (jumpAction && jumpAction.isRunning()) ? jumpAction : ((runAction && runAction.isRunning()) ? runAction : null); if (actionToPlay === currentAction) { if (name === 'jump') actionToPlay.reset().play(); return; } actionToPlay.reset(); actionToPlay.enabled = true; if (currentAction) { currentAction.crossFadeTo(actionToPlay, ANIMATION_FADE_TIME, true); } actionToPlay.play(); }

        // --- Game Loop ---
        function animate() { animationFrameId = requestAnimationFrame(animate); const deltaTime = clock.getDelta(); if (playerMixer) playerMixer.update(deltaTime); if (gameState === 'playing') { score += deltaTime * 10; // Score increases faster updateScoreDisplay(); if (gameSpeed < MAX_GAME_SPEED) gameSpeed += SPEED_INCREASE_RATE * deltaTime; updatePlayerPosition(deltaTime); handleJump(deltaTime); updateObstacles(deltaTime); spawnObstacles(deltaTime); checkCollisions(); const textureOffsetY = (clock.elapsedTime * gameSpeed * 0.05) % 1; if (ground.material.map) ground.material.map.offset.y = textureOffsetY; } renderer.render(scene, camera); }

        // --- Player Logic ---
        function updatePlayerPosition(deltaTime) { if (!player) return; const targetX = LANES[currentLane]; const lerpFactor = 10 * deltaTime; player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, lerpFactor); player.position.z = camera.position.z - 5; if (player) { playerBoundingBox.setFromObject(player, true); // Constantly update bounding box playerBoundingBox.expandByScalar(-0.1); } } // Shrink slightly for forgiveness
        function handleJump(deltaTime) { if (!player || player.userData.groundY === undefined) return; const groundLevel = player.userData.groundY; if (isJumping) { playerVelocityY -= GRAVITY * deltaTime; player.position.y += playerVelocityY * deltaTime; if (player.position.y <= groundLevel) { player.position.y = groundLevel; isJumping = false; playerVelocityY = 0; playAnimation('run'); } } }
        function jump() { if (!isJumping && gameState === 'playing' && player) { isJumping = true; playerVelocityY = JUMP_VELOCITY; playAnimation('jump'); } }
        function moveLane(direction) { if (gameState !== 'playing' || !player) return; const targetLane = currentLane + direction; if (targetLane >= 0 && targetLane < LANES.length) currentLane = targetLane; }

        // --- Obstacle Logic (Now uses loaded models if available with corrected scales) ---
        function createObstacle() {
            let obstacle = null; let data = null; let obstacleType = 'geometric';
            const obstacleOptions = [
                // Prioritize models if loaded
                { type: 'trashcan', model: cachedTrashcanModel, scale: TRASHCAN_SCALE, requiresDodge: false },
                { type: 'cactus', model: cachedCactusModel, scale: CACTUS_SCALE, requiresDodge: true },
                // Fallbacks (keep proportions somewhat reasonable relative to player scale 0.02)
                { type: 'lizard', geometry: new THREE.BoxGeometry(0.6, 0.2, 0.3), color: 0x90EE90, requiresDodge: false }, // Low profile
                { type: 'dog', geometry: new THREE.CapsuleGeometry(0.4, 0.6, 4, 8), color: 0x8B4513, requiresDodge: false }, // Jumpable maybe?
                { type: 'cat', geometry: new THREE.CapsuleGeometry(0.3, 0.4, 4, 8), color: 0xFFD700, requiresDodge: false }, // Jumpable
            ];
            data = obstacleOptions[Math.floor(Math.random() * obstacleOptions.length)];
            const laneIndex = Math.floor(Math.random() * LANES.length);

            if (data.model && cachedTrashcanModel && cachedCactusModel /* Check caches are populated */) { // Check specific caches
                // Only use the model option if it corresponds to a loaded cache
                if ((data.type === 'trashcan' && cachedTrashcanModel) || (data.type === 'cactus' && cachedCactusModel)) {
                    obstacle = data.model.clone(true); // CLONE the model
                    obstacle.scale.set(data.scale, data.scale, data.scale);
                    obstacleType = data.type;
                    obstacle.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
                } else {
                    // Fallback if the intended model isn't cached (shouldn't happen with current structure, but safe)
                    console.warn(`createObstacle: Model type ${data.type} selected but cache invalid, using fallback.`);
                    data = obstacleOptions.find(opt => opt.geometry && opt.type === 'lizard') || obstacleOptions[2]; // Find a default fallback
                    obstacle = new THREE.Mesh(data.geometry, new THREE.MeshStandardMaterial({ color: data.color }));
                    obstacleType = data.type;
                }
            } else if (data.geometry) { // Geometric fallback if model not chosen or not loaded
                const material = new THREE.MeshStandardMaterial({ color: data.color });
                obstacle = new THREE.Mesh(data.geometry, material);
                obstacleType = data.type;
                if(data.model) { // Log if a model was intended but cache failed
                     console.warn(`createObstacle: ${data.type} model not loaded or selected incorrectly, using fallback geometry.`);
                 }
            } else { console.error("Invalid obstacle data or model not loaded:", data); return; }

            obstacle.castShadow = true; obstacle.receiveShadow = true;
            obstacle.position.x = LANES[laneIndex]; obstacle.position.z = OBSTACLE_SPAWN_Z;

            // Calculate Y position based on bounding box (crucial for models)
            const tempBox = new THREE.Box3();
            // Ensure world matrix is updated before bounding box calculation AFTER scaling
            obstacle.updateMatrixWorld(true);
            tempBox.setFromObject(obstacle, true); // Precise world box of the scaled object

            const obstacleSize = new THREE.Vector3();
            tempBox.getSize(obstacleSize);
            const minY = tempBox.min.y;
            obstacle.position.y = -minY; // Position bottom at y=0 relative to its own origin

            // Store obstacle height for potential jump logic later
            obstacle.userData.height = obstacleSize.y;
            obstacle.userData.requiresDodge = data.requiresDodge; // Store if it's meant to be dodged

            // Add final object to scene
            scene.add(obstacle);

            obstacle.userData.boundingBox = new THREE.Box3();
            // Calculate final bounding box AFTER adding to scene and setting position
            obstacle.userData.boundingBox.setFromObject(obstacle, true);

            obstacles.push(obstacle);
            // console.log(`Created ${obstacleType} h: ${obstacle.userData.height.toFixed(2)} dodge: ${data.requiresDodge}`); // Optional log
        }
        function updateObstacles(deltaTime) { for (let i = obstacles.length - 1; i >= 0; i--) { const obstacle = obstacles[i]; obstacle.position.z += gameSpeed * deltaTime; // Update bounding box position with the mesh obstacle.userData.boundingBox.setFromObject(obstacle, true); if (obstacle.position.z > OBSTACLE_DESPAWN_Z) { scene.remove(obstacle); // Proper disposal for GLTF models and simple meshes if (obstacle.isMesh) { obstacle.geometry.dispose(); obstacle.material.dispose(); } else { obstacle.traverse(child => { if (child.isMesh) { child.geometry.dispose(); if(child.material) { // Materials can be shared, check before disposing // Safest might be to not dispose materials aggressively unless memory is a proven issue child.material.dispose(); } } }); } obstacles.splice(i, 1); } } }
        function spawnObstacles(deltaTime) { timeSinceLastSpawn += deltaTime; if (timeSinceLastSpawn > nextSpawnInterval) { createObstacle(); timeSinceLastSpawn = 0; nextSpawnInterval = calculateNextSpawnInterval(); } }
        function calculateNextSpawnInterval() { const speedFactor = Math.max(0.5, 1 - (gameSpeed / (MAX_GAME_SPEED * 1.5))); const min = OBSTACLE_SPAWN_INTERVAL_MIN * speedFactor; const max = OBSTACLE_SPAWN_INTERVAL_MAX * speedFactor; return Math.random() * (max - min) + min; }

        // --- Collision Detection ---
        function checkCollisions() { if (!player || !playerBoundingBox || gameState !== 'playing') return;
            // OPTIONAL: Visualize bounding boxes for debugging
            // removeOldBoxes(); // Helper to clear previous boxes
            // drawBoundingBox(playerBoundingBox, 0xff0000); // Red for player

            for (const obstacle of obstacles) {
                 // drawBoundingBox(obstacle.userData.boundingBox, 0x00ff00); // Green for obstacles
                if (playerBoundingBox.intersectsBox(obstacle.userData.boundingBox)) {
                    triggerGameOver(); return;
                 }
            }
        }
         // --- Optional Bounding Box Visualization Helpers ---
         /*
         let debugBoxes = [];
         function drawBoundingBox(box, color) {
             const helper = new THREE.Box3Helper(box, color);
             scene.add(helper);
             debugBoxes.push(helper);
         }
         function removeOldBoxes() {
             debugBoxes.forEach(box => scene.remove(box));
             debugBoxes = [];
         }
         */
        // --- End Optional Helpers ---


        // --- Game State Management ---
        function startGame() { console.log(`startGame: Called. Current state: ${gameState}, assetsLoaded: ${assetsLoaded}`); if (assetsLoaded && gameState === 'waiting') { gameState = 'playing'; console.log("startGame: State changed to 'playing'"); hideStartMessage(); gameOverScreen.style.display = 'none'; if (clock.running === false) { console.log("startGame: Starting clock."); clock.start(); } playAnimation('run'); console.log("startGame: Function finished."); } else { console.warn(`startGame: Conditions not met! State: ${gameState}, assetsLoaded: ${assetsLoaded}`); } }
        function triggerGameOver() { if (gameState === 'playing') { gameState = 'gameOver'; saveHighScore(); updateHighScoreDisplay(); finalScoreElement.textContent = `Your Score: ${Math.floor(score)}`; sessionHighScoreElement.textContent = `High Score: ${highScore}`; gameOverScreen.style.display = 'flex'; if (runAction) runAction.stop(); if (jumpAction) jumpAction.stop(); // Stop animations immediately clock.stop(); // Stop the clock } }
        function resetGame() {
            const newGroundIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length); const newGroundPath = GROUND_TEXTURE_PATHS[newGroundIndex]; console.log("resetGame: Loading new ground texture:", newGroundPath);
            textureLoader.load(newGroundPath, (texture) => { texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40)); ground.material.map = texture; ground.material.needsUpdate = true; console.log("resetGame: Ground texture updated."); }, undefined, (err) => { console.error("resetGame: Failed loading ground texture:", newGroundPath, err); ground.material.map = null; ground.material.needsUpdate = true; } );
            if (!player || player.userData.groundY === undefined) { console.error("Reset failed: Player or groundY undefined."); return; }
             // Clear obstacles properly
            obstacles.forEach(obstacle => {
                scene.remove(obstacle);
                // Dispose geometry/materials
                if (obstacle.isMesh) {
                     obstacle.geometry.dispose();
                     obstacle.material.dispose();
                 } else { // Handle GLTF groups
                     obstacle.traverse(child => {
                         if (child.isMesh) {
                             child.geometry.dispose();
                             // Consider material disposal strategy - if materials are reused, don't dispose here.
                             // If they are unique per clone, dispose. For now, let's assume unique.
                             if(child.material) child.material.dispose();
                         }
                     });
                 }
            });
            obstacles = [];

            player.position.copy(PLAYER_START_POS); player.position.y = player.userData.groundY; playerBoundingBox.setFromObject(player, true); currentLane = 1; isJumping = false; playerVelocityY = 0;
            score = 0; gameSpeed = INITIAL_GAME_SPEED; timeSinceLastSpawn = 0; nextSpawnInterval = calculateNextSpawnInterval();
            updateScoreDisplay(); gameOverScreen.style.display = 'none'; gameState = 'waiting'; gameStartedOnce = false; // Reset flag
            showStartMessage("Press Any Key or Click to Start");
            if (playerMixer) { if(jumpAction && jumpAction.isRunning()) jumpAction.stop(); if(runAction) runAction.reset().play(); }
            clock.start(); // Restart the clock
            // removeOldBoxes(); // Clear debug boxes if using
        }

        // --- UI & Scoring ---
        function updateScoreDisplay() { scoreElement.textContent = `Score: ${Math.floor(score)}`; }
        function updateHighScoreDisplay() { highScoreElement.textContent = `High Score: ${highScore}`; }
        function showStartMessage(message = "Loading...", permanent = false) { startMessage.textContent = message; startMessage.style.display = 'block'; startMessage.style.pointerEvents = (gameState === 'loading' || permanent) ? 'none' : 'all'; }
        function hideStartMessage() { startMessage.style.display = 'none'; }

        // --- Local Storage ---
        function saveHighScore() { if (Math.floor(score) > highScore) { highScore = Math.floor(score); try { localStorage.setItem(HIGH_SCORE_KEY, highScore.toString()); } catch (e) { console.error("Could not save high score:", e); } } }
        function loadHighScore() { try { const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY); if (storedHighScore !== null) highScore = parseInt(storedHighScore, 10) || 0; } catch (e) { console.error("Could not load high score:", e); highScore = 0; } }

        // --- Event Handlers ---
        function onWindowResize() { const newWidth = gameContainer.clientWidth; const newHeight = gameContainer.clientHeight; camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix(); renderer.setSize(newWidth, newHeight); }
        function startGameOnce() { console.log(`startGameOnce: Called. gameStartedOnce: ${gameStartedOnce}, assetsLoaded: ${assetsLoaded}, gameState: ${gameState}`); if (!gameStartedOnce && assetsLoaded && gameState === 'waiting') { gameStartedOnce = true; console.log("startGameOnce: Conditions met, calling startGame()."); startGame(); } else { console.log("startGameOnce: Conditions not met or already started."); } }
        function onKeyDown(event) { /* console.log(`onKeyDown: Key '${event.code}' pressed. State: ${gameState}, StartedOnce: ${gameStartedOnce}`);*/ if (!gameStartedOnce && assetsLoaded && gameState === 'waiting') { /* console.log("onKeyDown: First keypress detected, waiting for startGameOnce listener."); */ return; } if (gameState !== 'playing') { /* console.log("onKeyDown: Not in 'playing' state, ignoring movement."); */ return; } switch (event.code) { case 'ArrowLeft': case 'KeyA': /* console.log("onKeyDown: Moving left.");*/ moveLane(-1); break; case 'ArrowRight': case 'KeyD': /* console.log("onKeyDown: Moving right.");*/ moveLane(1); break; case 'Space': case 'ArrowUp': case 'KeyW': /* console.log("onKeyDown: Jumping.");*/ jump(); break; } }

        // --- Start the experience ---
        init();

    </script>
</body>
</html>
