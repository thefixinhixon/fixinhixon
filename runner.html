<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Runner</title>
    <style>
        /* --- Updated CSS for Full Screen --- */
        body {
            margin: 0;
            overflow: hidden; /* Keep this to prevent scrollbars */
            background-color: #222;
            color: white;
            font-family: 'Arial', sans-serif;
            /* Removed flex centering */
        }
        #gameContainer {
            position: relative; /* Keep for absolute positioning of UI */
            width: 100vw; /* Fill viewport width */
            height: 100vh; /* Fill viewport height */
            /* border: none; Removed */
        }
        /* --- End Updated CSS --- */

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #uiContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
        #score { }
        #highScoreDisplay { }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 28px;
            pointer-events: all;
        }
        #gameOverScreen h2 { margin-bottom: 15px; }
        #finalScore, #sessionHighScore { margin-bottom: 20px; }
        #restartButton {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        #restartButton:hover { background-color: #45a049; }
        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            background-color: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="score">Score: 0</div>
            <div id="highScoreDisplay">High Score: 0</div>
        </div>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <div id="finalScore">Your Score: 0</div>
            <div id="sessionHighScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
         <div id="startMessage">Loading Assets...</div>
    </div>

    <!-- Import map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        const LANE_WIDTH = 2.5;
        const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const PLAYER_START_POS = new THREE.Vector3(0, 0, 10);
        // --- CHANGE START ---
        const PLAYER_RUN_MODEL_PATH = 'raccoon.glb';   // Path for running model/animation
        const PLAYER_JUMP_MODEL_PATH = 'raccoon_jump.glb'; // Path for jumping animation model
        const PLAYER_MODEL_SCALE = 0.1; // <<< ADJUST THIS SCALE based on your model size!
        const ANIMATION_FADE_TIME = 0.2; // Seconds for animation crossfade
        // --- CHANGE END ---
        const INITIAL_GAME_SPEED = 8;
        const MAX_GAME_SPEED = 30;
        const SPEED_INCREASE_RATE = 0.1;
        const OBSTACLE_SPAWN_Z = -50;
        const OBSTACLE_DESPAWN_Z = 15;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 0.8;
        const OBSTACLE_SPAWN_INTERVAL_MAX = 2.0;
        const JUMP_VELOCITY = 10;
        const GRAVITY = 25;
        const HIGH_SCORE_KEY = 'raccoonRunnerHighScore';

        // --- Game State ---
        let scene, camera, renderer, clock, player;
        let gameSpeed = INITIAL_GAME_SPEED;
        let obstacles = [];
        let currentLane = 1;
        let score = 0;
        let highScore = 0;
        let timeSinceLastSpawn = 0;
        let nextSpawnInterval = calculateNextSpawnInterval();
        let isJumping = false;
        let playerVelocityY = 0;
        let gameState = 'loading'; // 'loading', 'waiting', 'playing', 'gameOver', 'error'
        let animationFrameId = null;
        // --- CHANGE START ---
        let playerMixer = null;
        let playerAnimations = {}; // Store animations by name (e.g., 'run', 'jump')
        let runAction = null;
        let jumpAction = null;
        // --- CHANGE END ---
        let playerBoundingBox = new THREE.Box3();
        let playerHeight = 1;
        let assetsLoaded = false;
        let gameStartedOnce = false; // Flag for initial start interaction reset fix

        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameContainer = document.getElementById('gameContainer');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScoreDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const sessionHighScoreElement = document.getElementById('sessionHighScore');
        const restartButton = document.getElementById('restartButton');
        const startMessage = document.getElementById('startMessage');

        // --- Initialization ---
        function init() {
            // Basic Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);
            clock = new THREE.Clock();

            // Camera
            const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 4, 15);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            // Shadow settings (same as before)
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(20, 150);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            // Load High Score
            loadHighScore();
            updateHighScoreDisplay();

            // --- CHANGE START ---
            // Load all assets concurrently
            loadAssets().then(() => {
                // This runs when both models are loaded successfully
                assetsLoaded = true;
                gameState = 'waiting';
                showStartMessage("Press Any Key or Click to Start");
                // Add start listeners *after* assets are loaded
                window.addEventListener('keydown', startGameOnce);
                window.addEventListener('mousedown', startGameOnce);
                console.log("Assets loaded, ready to start.");
                 playAnimation('run'); // Start with the run animation
            }).catch(error => {
                console.error("Failed to load assets:", error);
                showStartMessage("Error loading assets. Please refresh.", true);
                gameState = 'error';
            });
            // --- CHANGE END ---

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            restartButton.addEventListener('click', resetGame);

            // Start the animation loop
            animate();
        }

        // --- CHANGE START ---
        // Function to load all GLB assets using Promises
        function loadAssets() {
            const loader = new GLTFLoader();
            const runPromise = loader.loadAsync(PLAYER_RUN_MODEL_PATH); // Use loadAsync for promises
            const jumpPromise = loader.loadAsync(PLAYER_JUMP_MODEL_PATH);

            return Promise.all([runPromise, jumpPromise]).then(([gltfRun, gltfJump]) => {
                // --- Player Model Setup (using the run model's scene) ---
                player = gltfRun.scene;
                player.scale.set(PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE);
                player.rotation.y = Math.PI;
                player.position.copy(PLAYER_START_POS);

                player.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                    }
                });

                // Calculate bounding box and height (same as before)
                scene.add(player); // Temporarily add to calculate world box
                playerBoundingBox.setFromObject(player, true);
                const playerSize = new THREE.Vector3();
                playerBoundingBox.getSize(playerSize);
                playerHeight = playerSize.y;
                player.position.y = playerHeight / 2;
                playerBoundingBox.setFromObject(player, true); // Recalculate after positioning

                console.log("Player model processed. Height:", playerHeight);

                // --- Animation Setup ---
                playerMixer = new THREE.AnimationMixer(player);

                // Extract and store run animation (assume first animation is run)
                if (gltfRun.animations && gltfRun.animations.length > 0) {
                    playerAnimations['run'] = gltfRun.animations[0];
                    runAction = playerMixer.clipAction(playerAnimations['run']);
                    runAction.setLoop(THREE.LoopRepeat); // Make sure run loops
                    console.log("Run animation loaded:", playerAnimations['run'].name);
                } else {
                    console.warn("No animations found in run model:", PLAYER_RUN_MODEL_PATH);
                }

                // Extract and store jump animation (assume first animation is jump)
                if (gltfJump.animations && gltfJump.animations.length > 0) {
                    // IMPORTANT: Use the *player* object (from run model) for the mixer,
                    // but the *animation clip* from the jump model.
                    playerAnimations['jump'] = gltfJump.animations[0];
                    jumpAction = playerMixer.clipAction(playerAnimations['jump']);
                    jumpAction.setLoop(THREE.LoopOnce); // Jump plays only once
                    jumpAction.clampWhenFinished = true; // Stay on the last frame when done
                    console.log("Jump animation loaded:", playerAnimations['jump'].name);
                } else {
                    console.warn("No animations found in jump model:", PLAYER_JUMP_MODEL_PATH);
                }

                // Basic check
                if (!runAction) {
                    throw new Error("Run animation action could not be created.");
                }

            }); // No need for separate .catch here, the main one in init() handles it
        }

        // Helper function to play animations with crossfade
        function playAnimation(name) {
            if (!playerMixer || !assetsLoaded) return;

            const actionToPlay = name === 'jump' ? jumpAction : runAction;
            const currentAction = (jumpAction && jumpAction.isRunning()) ? jumpAction : runAction;

            if (!actionToPlay) {
                console.warn(`Animation action "${name}" not found.`);
                return;
            }

            // Avoid fading from/to the same animation or if target is already playing
            if (actionToPlay === currentAction && actionToPlay.isRunning()) {
                 // If trying to play jump again while it's running, maybe reset and play?
                 if(name === 'jump') {
                      actionToPlay.reset().play();
                 }
                return;
            }


            if (currentAction && currentAction.isRunning()) {
                 // Ensure the new action is reset before playing
                 actionToPlay.reset();
                 // Fade from current to new action
                 actionToPlay.enabled = true; // Make sure it's enabled if previously disabled
                 currentAction.crossFadeTo(actionToPlay, ANIMATION_FADE_TIME, true); // true = warp
                 actionToPlay.play();
            } else {
                 // If no action is currently playing, just play the target
                actionToPlay.reset().play();
            }
        }
        // --- CHANGE END ---


        // --- Game Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // Update animation mixer regardless of game state
            if (playerMixer) {
                playerMixer.update(deltaTime);
            }

             if (gameState === 'playing') {
                score += deltaTime;
                updateScoreDisplay();
                 if (gameSpeed < MAX_GAME_SPEED) {
                     gameSpeed += SPEED_INCREASE_RATE * deltaTime;
                 }
                updatePlayerPosition(deltaTime);
                handleJump(deltaTime); // Checks for landing
                updateObstacles(deltaTime);
                spawnObstacles(deltaTime);
                checkCollisions();
            }

            renderer.render(scene, camera);
        }

        // --- Player Logic ---
         function updatePlayerPosition(deltaTime) {
            if (!player) return;
            const targetX = LANES[currentLane];
            const lerpFactor = 10 * deltaTime;
            player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, lerpFactor);
            player.position.z = camera.position.z - 5;

            // Update bounding box (same as before)
             if (player) {
                 playerBoundingBox.setFromObject(player, true);
                 playerBoundingBox.expandByScalar(-0.1); // Optional adjustment
             }
        }

        function handleJump(deltaTime) {
             if (!player) return;
             const groundLevel = playerHeight / 2;

             if (isJumping) {
                playerVelocityY -= GRAVITY * deltaTime;
                player.position.y += playerVelocityY * deltaTime;

                 if (player.position.y <= groundLevel) {
                    player.position.y = groundLevel;
                    isJumping = false;
                    playerVelocityY = 0;
                    // --- CHANGE START ---
                    // Play run animation when landing
                    playAnimation('run');
                    // --- CHANGE END ---
                }
            }
        }

         function jump() {
            // Allow jump only when playing, player exists, and not already jumping
            if (!isJumping && gameState === 'playing' && player) {
                isJumping = true;
                playerVelocityY = JUMP_VELOCITY;
                // --- CHANGE START ---
                // Play jump animation
                playAnimation('jump');
                // --- CHANGE END ---
            }
        }

         function moveLane(direction) {
            if (gameState !== 'playing' || !player) return;
            const targetLane = currentLane + direction;
            if (targetLane >= 0 && targetLane < LANES.length) {
                currentLane = targetLane;
            }
        }

        // --- Obstacle Logic (createObstacle, updateObstacles, spawnObstacles, calculateNextSpawnInterval) ---
        // Remains unchanged from the previous version
        function createObstacle() {
            const obstacleTypes = [
                { type: 'trashcan', geometry: new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16), color: 0x888888 },
                { type: 'cactus', geometry: new THREE.BoxGeometry(0.8, 1.5, 0.8), color: 0x228B22 },
                { type: 'lizard', geometry: new THREE.BoxGeometry(1.0, 0.3, 0.4), color: 0x90EE90 },
                { type: 'dog', geometry: new THREE.CapsuleGeometry(0.6, 1.0, 4, 8), color: 0x8B4513 },
                { type: 'cat', geometry: new THREE.CapsuleGeometry(0.4, 0.7, 4, 8), color: 0xFFD700 },
            ];
             const data = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const material = new THREE.MeshStandardMaterial({ color: data.color });
            const obstacle = new THREE.Mesh(data.geometry, material);
             obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            const laneIndex = Math.floor(Math.random() * LANES.length);
            obstacle.position.x = LANES[laneIndex];
            obstacle.position.z = OBSTACLE_SPAWN_Z;
            // Adjust Y position based on geometry center
            if (data.geometry.type === 'BoxGeometry') obstacle.position.y = data.geometry.parameters.height / 2;
            else if (data.geometry.type === 'CylinderGeometry') obstacle.position.y = data.geometry.parameters.height / 2;
            else if (data.geometry.type === 'CapsuleGeometry') obstacle.position.y = data.geometry.parameters.length / 2 + data.geometry.parameters.radius;
            else obstacle.position.y = 0.5;
            obstacle.userData.boundingBox = new THREE.Box3();
            scene.add(obstacle);
            obstacle.userData.boundingBox.setFromObject(obstacle); // Calculate AFTER adding
            obstacles.push(obstacle);
        }
        function updateObstacles(deltaTime) {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += gameSpeed * deltaTime;
                obstacle.userData.boundingBox.setFromObject(obstacle); // Update box
                if (obstacle.position.z > OBSTACLE_DESPAWN_Z) {
                    scene.remove(obstacle);
                    obstacle.geometry.dispose();
                    obstacle.material.dispose();
                    obstacles.splice(i, 1);
                }
            }
        }
         function spawnObstacles(deltaTime) {
            timeSinceLastSpawn += deltaTime;
            if (timeSinceLastSpawn > nextSpawnInterval) {
                createObstacle();
                timeSinceLastSpawn = 0;
                nextSpawnInterval = calculateNextSpawnInterval();
            }
        }
         function calculateNextSpawnInterval() {
            const speedFactor = Math.max(0.5, 1 - (gameSpeed / (MAX_GAME_SPEED * 1.5)));
            const min = OBSTACLE_SPAWN_INTERVAL_MIN * speedFactor;
            const max = OBSTACLE_SPAWN_INTERVAL_MAX * speedFactor;
            return Math.random() * (max - min) + min;
        }

        // --- Collision Detection ---
        function checkCollisions() {
             if (!player || !playerBoundingBox || gameState !== 'playing') return;
            for (const obstacle of obstacles) {
                 if (playerBoundingBox.intersectsBox(obstacle.userData.boundingBox)) {
                    triggerGameOver();
                    return;
                }
            }
        }

        // --- Game State Management ---
        function startGame() {
            if (assetsLoaded && gameState === 'waiting') {
                 gameState = 'playing';
                 hideStartMessage();
                 gameOverScreen.style.display = 'none';
                 if (clock.running === false) clock.start();
                 // --- CHANGE START ---
                 // Ensure run animation is playing when game starts
                 playAnimation('run');
                 // --- CHANGE END ---
            }
        }

        function triggerGameOver() {
            if (gameState === 'playing') {
                gameState = 'gameOver';
                saveHighScore();
                updateHighScoreDisplay();
                finalScoreElement.textContent = `Your Score: ${Math.floor(score)}`;
                sessionHighScoreElement.textContent = `High Score: ${highScore}`;
                gameOverScreen.style.display = 'flex';
                 // Optional: Could stop the animation mixer or play a death animation here
                 // if (playerMixer) playerMixer.stopAllAction();
            }
        }

        function resetGame() {
             if (!player) return; // Cannot reset if player never loaded

            // Clear obstacles (same as before)
            obstacles.forEach(obstacle => {
                scene.remove(obstacle);
                obstacle.geometry.dispose();
                obstacle.material.dispose();
            });
            obstacles = [];

            // Reset player position/state (same as before)
            player.position.copy(PLAYER_START_POS);
            player.position.y = playerHeight / 2;
            playerBoundingBox.setFromObject(player, true);
            currentLane = 1;
            isJumping = false;
            playerVelocityY = 0;

            // Reset game variables (same as before)
            score = 0;
            gameSpeed = INITIAL_GAME_SPEED;
            timeSinceLastSpawn = 0;
            nextSpawnInterval = calculateNextSpawnInterval();
            updateScoreDisplay();

            // UI updates (same as before)
            gameOverScreen.style.display = 'none';
            gameState = 'waiting';
            gameStartedOnce = false; // <<< FIX: Reset the start flag
            showStartMessage("Press Any Key or Click to Start");

            // --- CHANGE START ---
            // Reset and play the run animation for the waiting state
            if (playerMixer) {
                 if(jumpAction && jumpAction.isRunning()) jumpAction.stop(); // Stop jump if it was somehow running
                 if(runAction) runAction.reset().play(); // Ensure run is playing
            }
            // --- CHANGE END ---

             if (clock.running === false) clock.start();
        }

        // --- UI & Scoring ---
        function updateScoreDisplay() { scoreElement.textContent = `Score: ${Math.floor(score)}`; }
        function updateHighScoreDisplay() { highScoreElement.textContent = `High Score: ${highScore}`; }
        function showStartMessage(message = "Loading...", permanent = false) {
            startMessage.textContent = message;
            startMessage.style.display = 'block';
            startMessage.style.pointerEvents = (gameState === 'loading' || permanent) ? 'none' : 'all';
        }
        function hideStartMessage() { startMessage.style.display = 'none'; }

        // --- Local Storage ---
        function saveHighScore() {
            if (Math.floor(score) > highScore) {
                highScore = Math.floor(score);
                try { localStorage.setItem(HIGH_SCORE_KEY, highScore.toString()); }
                catch (e) { console.error("Could not save high score:", e); }
            }
        }
        function loadHighScore() {
            try {
                const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
                if (storedHighScore !== null) highScore = parseInt(storedHighScore, 10) || 0;
            } catch (e) { console.error("Could not load high score:", e); highScore = 0; }
        }

        // --- Event Handlers ---
        function onWindowResize() {
            const newWidth = gameContainer.clientWidth;
            const newHeight = gameContainer.clientHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        function startGameOnce() {
             if (!gameStartedOnce && assetsLoaded && gameState === 'waiting') {
                 gameStartedOnce = true;
                 startGame();
            }
         }

        function onKeyDown(event) {
            if (!gameStartedOnce && assetsLoaded && gameState === 'waiting') {
                startGameOnce();
                return;
            }
             if (gameState !== 'playing') return;
            switch (event.code) {
                case 'ArrowLeft': case 'KeyA': moveLane(-1); break;
                case 'ArrowRight': case 'KeyD': moveLane(1); break;
                case 'Space': case 'ArrowUp': case 'KeyW': jump(); break;
            }
        }

        // --- Start the experience ---
        init();

    </script>
</body>
</html>
