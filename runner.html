<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Runner</title>
    <style>
        /* CSS remains the same */
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: 'Arial', sans-serif; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #uiContainer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; pointer-events: none; font-size: 24px; text-shadow: 1px 1px 2px black; }
        #score { } #highScoreDisplay { }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 28px; pointer-events: all; }
        #gameOverScreen h2 { margin-bottom: 15px; } #finalScore, #sessionHighScore { margin-bottom: 20px; }
        #restartButton { padding: 15px 30px; font-size: 20px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; transition: background-color 0.3s ease; }
        #restartButton:hover { background-color: #45a049; }
        #startMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; text-align: center; background-color: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="score">Score: 0</div>
            <div id="highScoreDisplay">High Score: 0</div>
        </div>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <div id="finalScore">Your Score: 0</div>
            <div id="sessionHighScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
         <div id="startMessage">Loading Assets...</div>
    </div>

    <!-- Import map -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        const LANE_WIDTH = 2.5; const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const PLAYER_START_POS = new THREE.Vector3(0, 0, 10);
        const PLAYER_RUN_MODEL_PATH = 'raccoon.glb'; const PLAYER_JUMP_MODEL_PATH = 'raccoon_jump.glb';
        const PLAYER_MODEL_SCALE = 0.02; const ANIMATION_FADE_TIME = 0.2;
        const INITIAL_GAME_SPEED = 8; const MAX_GAME_SPEED = 30; const SPEED_INCREASE_RATE = 0.1;
        const OBSTACLE_SPAWN_Z = -50; const OBSTACLE_DESPAWN_Z = 15;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 0.8; const OBSTACLE_SPAWN_INTERVAL_MAX = 2.0;
        const JUMP_VELOCITY = 10; const GRAVITY = 25; const HIGH_SCORE_KEY = 'raccoonRunnerHighScore';
        const GROUND_TEXTURE_PATHS = [ 'ground1.jpg', 'ground2.jpg', 'ground3.jpg', 'ground4.jpg' ];
        const SKY_TEXTURE_PATH = 'sky.jpg'; const GROUND_TEXTURE_REPEAT = 10;
        const GROUND_FADE_INTERVAL = 30.0; const GROUND_FADE_DURATION = 1.5;

        // --- CHANGE START: Obstacle Model Config ---
        const TRASHCAN_MODEL_PATH = 'trashcan.glb';
        const CACTUS_MODEL_PATH = 'cactus.glb';
        const TRASHCAN_SCALE = 0.8; // Adjust as needed
        const CACTUS_SCALE = 0.7;   // Adjust as needed
        // --- CHANGE END ---


        // --- Game State ---
        let scene, camera, renderer, clock, player, ground;
        // ... other game state variables ...
        let gameState = 'loading'; let animationFrameId = null;
        let playerMixer = null; let playerAnimations = {}; let runAction = null; let jumpAction = null;
        let playerBoundingBox = new THREE.Box3(); let playerHeight = 1;
        let assetsLoaded = false; let gameStartedOnce = false;
        let textureLoader; let groundMaterials = []; let currentGroundTextureIndex = 0;
        let visibleMaterialIndex = 0; let timeSinceLastGroundFade = 0;
        let isFadingGround = false; let groundFadeTimer = 0; let nextGroundTexture = null;

        // --- CHANGE START: Obstacle Model Cache ---
        let gltfLoader; // Make loader accessible globally in module
        let cachedTrashcanModel = null;
        let cachedCactusModel = null;
        // --- CHANGE END ---

        // --- DOM Elements (remain the same) ---
        const gameCanvas = document.getElementById('gameCanvas'); /* ... */ const startMessage = document.getElementById('startMessage');

        // --- Initialization ---
        function init() {
            console.log("init: Started.");
            textureLoader = new THREE.TextureLoader();
            gltfLoader = new GLTFLoader(); // Initialize GLTF loader here

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60); clock = new THREE.Clock();
            const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 4, 15); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7); directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // --- Ground Setup ---
            const groundGeometry = new THREE.PlaneGeometry(40, 150);
            // Explicitly set properties for initial visibility
            groundMaterials[0] = new THREE.MeshStandardMaterial({
                color: 0xffffff, // Use white base color, texture will override
                side: THREE.DoubleSide,
                transparent: false, // NOT transparent initially
                opacity: 1.0,       // Fully opaque
            });
            groundMaterials[1] = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true, // Second one IS transparent
                opacity: 0,
                map: null, // Start with no map
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterials);
            ground.rotation.x = -Math.PI / 2; ground.position.y = 0; ground.receiveShadow = true;
            scene.add(ground);
            console.log("init: Ground mesh created and added.");

            loadHighScore(); updateHighScoreDisplay();

            console.log("init: Calling loadAssets()...");
            loadAssets().then(() => {
                console.log("init: loadAssets() promise resolved successfully.");
                assetsLoaded = true;
                gameState = 'waiting';
                showStartMessage("Press Any Key or Click to Start");
                window.addEventListener('keydown', startGameOnce);
                window.addEventListener('mousedown', startGameOnce);
                console.log("init: Game ready state set.");
                playAnimation('run');
            }).catch(error => {
                console.error("init: CRITICAL ERROR during asset loading:", error);
                showStartMessage("Error loading assets. Please refresh.", true);
                gameState = 'error';
            });

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            restartButton.addEventListener('click', resetGame);
            console.log("init: Starting animation loop...");
            animate();
            console.log("init: Function finished.");
        }

        // --- Asset Loading (including Obstacle Models) ---
        function loadAssets() {
            console.log("loadAssets: Starting...");
            const runPromise = gltfLoader.loadAsync(PLAYER_RUN_MODEL_PATH);
            const jumpPromise = gltfLoader.loadAsync(PLAYER_JUMP_MODEL_PATH);
            const skyPromise = textureLoader.loadAsync(SKY_TEXTURE_PATH);
            currentGroundTextureIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length);
            const initialGroundPath = GROUND_TEXTURE_PATHS[currentGroundTextureIndex];
            console.log("loadAssets: Loading initial ground:", initialGroundPath);
            const groundPromise = textureLoader.loadAsync(initialGroundPath);

            // --- CHANGE START: Add obstacle models to loading ---
            const trashcanPromise = gltfLoader.loadAsync(TRASHCAN_MODEL_PATH);
            const cactusPromise = gltfLoader.loadAsync(CACTUS_MODEL_PATH);
            // --- CHANGE END ---

            console.log("loadAssets: Promises created, awaiting Promise.all...");
            // Add obstacle promises to Promise.all
            return Promise.all([runPromise, jumpPromise, skyPromise, groundPromise, trashcanPromise, cactusPromise])
                .then(([gltfRun, gltfJump, skyTexture, initialGroundTexture, gltfTrashcan, gltfCactus]) => { // Destructure results
                    console.log("loadAssets: Promise.all resolved.");

                    // --- CHANGE START: Cache obstacle models ---
                    console.log("loadAssets: Caching obstacle models...");
                    cachedTrashcanModel = gltfTrashcan.scene;
                    cachedCactusModel = gltfCactus.scene;
                     // Optional: You might want to pre-configure shadows or other properties on the cached models once here
                    // cachedTrashcanModel.traverse(child => { if (child.isMesh) child.castShadow = true; });
                    // cachedCactusModel.traverse(child => { if (child.isMesh) child.castShadow = true; });
                    console.log("loadAssets: Obstacle models cached.");
                    // --- CHANGE END ---

                    // Player Model Setup (remains the same)
                    console.log("loadAssets: Setting up player model...");
                    player = gltfRun.scene; /* ... scale, rotation, position, groundY calc ... */
                    player.scale.set(PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE); player.rotation.y = Math.PI; player.position.set(PLAYER_START_POS.x, 0, PLAYER_START_POS.z); player.traverse(child => { if (child.isMesh) child.castShadow = true; }); scene.add(player); playerBoundingBox.setFromObject(player, true); const ps = new THREE.Vector3(); playerBoundingBox.getSize(ps); playerHeight = ps.y; const mnY = playerBoundingBox.min.y; const go = -mnY; player.position.y = go; player.userData.groundY = go; playerBoundingBox.setFromObject(player, true);
                    console.log("loadAssets: Player model setup complete.");

                    // Animation Setup (remains the same)
                    console.log("loadAssets: Setting up animations...");
                    playerMixer = new THREE.AnimationMixer(player); /* ... create actions ... */
                     if (gltfRun.animations && gltfRun.animations.length > 0) { playerAnimations['run'] = gltfRun.animations[0]; runAction = playerMixer.clipAction(playerAnimations['run']); runAction.setLoop(THREE.LoopRepeat); } else { console.warn("No run anim"); }
                     if (gltfJump.animations && gltfJump.animations.length > 0) { playerAnimations['jump'] = gltfJump.animations[0]; jumpAction = playerMixer.clipAction(playerAnimations['jump']); jumpAction.setLoop(THREE.LoopOnce); jumpAction.clampWhenFinished = true;} else { console.warn("No jump anim"); }
                     if (!runAction) { console.error("CRITICAL: Run animation action failed."); }
                    console.log("loadAssets: Animation setup complete.");

                    // Apply Textures
                    console.log("loadAssets: Applying textures...");
                    skyTexture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = skyTexture; scene.environment = skyTexture;
                    // Apply initial ground texture explicitly to material 0
                    initialGroundTexture.wrapS = THREE.RepeatWrapping; initialGroundTexture.wrapT = THREE.RepeatWrapping;
                    initialGroundTexture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40));
                    groundMaterials[0].map = initialGroundTexture; // Apply to the visible one
                    groundMaterials[0].needsUpdate = true;
                    // Ensure the second material has no map initially
                    groundMaterials[1].map = null;
                    groundMaterials[1].opacity = 0;
                    groundMaterials[1].needsUpdate = true;
                    console.log("loadAssets: Initial ground texture applied to material 0.");
                    console.log("loadAssets: Textures applied.");

                    // Preload next ground texture (still useful for fading)
                    console.log("loadAssets: Calling preloadNextGroundTexture...");
                    preloadNextGroundTexture();
                    console.log("loadAssets: Returned from preloadNextGroundTexture call.");
                    console.log("loadAssets: .then() block finished successfully.");

                }).catch(error => {
                     console.error("loadAssets: Error within Promise.all or its .then():", error);
                     throw error; // Propagate error to init's catch block
                });
        }

        // --- Preload with Error Handling (remains the same) ---
        function preloadNextGroundTexture() { /* ... */ }
        // --- Ground Texture Fading Logic (remains the same) ---
        function startGroundFade() { /* ... */ }
        function updateGroundFade(deltaTime) { /* ... */ }
        // --- Helper function to play animations (remains the same) ---
        function playAnimation(name) { /* ... */ }
        // --- Game Loop (remains the same) ---
        function animate() { /* ... */ }
        // --- Player Logic (remains the same) ---
        function updatePlayerPosition(deltaTime) { /* ... */ }
        function handleJump(deltaTime) { /* ... */ }
        function jump() { /* ... */ }
        function moveLane(direction) { /* ... */ }


        // --- Obstacle Logic (Modified createObstacle) ---
        function createObstacle() {
            let obstacle = null;
            let data = null; // Store data for later use if needed
            let obstacleType = 'geometric'; // default type

            // --- Define potential obstacles ---
            const obstacleOptions = [
                { type: 'trashcan', model: cachedTrashcanModel, scale: TRASHCAN_SCALE },
                { type: 'cactus', model: cachedCactusModel, scale: CACTUS_SCALE },
                // Keep geometric shapes as fallbacks or variety
                { type: 'lizard', geometry: new THREE.BoxGeometry(1.0, 0.3, 0.4), color: 0x90EE90 },
                { type: 'dog', geometry: new THREE.CapsuleGeometry(0.6, 1.0, 4, 8), color: 0x8B4513 },
                { type: 'cat', geometry: new THREE.CapsuleGeometry(0.4, 0.7, 4, 8), color: 0xFFD700 },
            ];

            // Choose a random obstacle type
            data = obstacleOptions[Math.floor(Math.random() * obstacleOptions.length)];
            const laneIndex = Math.floor(Math.random() * LANES.length);

            // --- Create based on type ---
            if (data.model) { // It's a loaded model
                if (data.model) { // Check if the cached model actually loaded
                    obstacle = data.model.clone(true); // CLONE the model
                    obstacle.scale.set(data.scale, data.scale, data.scale);
                    obstacleType = data.type; // Set specific type
                } else {
                    console.warn(`Attempted to create ${data.type}, but model not loaded. Skipping.`);
                    return; // Don't create anything if model isn't ready
                }
            } else if (data.geometry) { // It's a geometric shape
                const material = new THREE.MeshStandardMaterial({ color: data.color });
                obstacle = new THREE.Mesh(data.geometry, material);
                obstacleType = data.type; // Set specific type (lizard, dog, cat)
            } else {
                console.error("Invalid obstacle data:", data);
                return; // Skip if data is wrong
            }

            // --- Common Setup for all obstacles ---
            obstacle.castShadow = true;
            obstacle.receiveShadow = true; // Models might look better receiving shadows too

            // Enable shadows for all children of cloned models
             if (data.model) {
                 obstacle.traverse(child => {
                     if (child.isMesh) {
                         child.castShadow = true;
                         child.receiveShadow = true;
                     }
                 });
             }

            // Set initial position (X and Z)
            obstacle.position.x = LANES[laneIndex];
            obstacle.position.z = OBSTACLE_SPAWN_Z;

            // Calculate initial Y position AFTER setting scale and adding to scene temporarily
            scene.add(obstacle); // Add temporarily
            const box = new THREE.Box3().setFromObject(obstacle);
            const size = new THREE.Vector3(); box.getSize(size);
            const minY = box.min.y;
            obstacle.position.y = -minY; // Place bottom at y=0
            scene.remove(obstacle); // Remove temporary add

            // Final add to scene
            scene.add(obstacle);

            // Calculate and store final bounding box
            obstacle.userData.boundingBox = new THREE.Box3();
            obstacle.userData.boundingBox.setFromObject(obstacle); // Final calculation

            obstacles.push(obstacle);
            // console.log("Created obstacle:", obstacleType); // Optional log
        }
        function updateObstacles(deltaTime) { /* ... remains the same ... */ }
        function spawnObstacles(deltaTime) { /* ... remains the same ... */ }
        function calculateNextSpawnInterval() { /* ... remains the same ... */ }

        // --- Collision Detection (remains the same) ---
        function checkCollisions() { /* ... */ }
        // --- Game State Management (remains the same, including resetGame texture logic) ---
        function startGame() { /* ... */ }
        function triggerGameOver() { /* ... */ }
        function resetGame() { /* ... */ }
        // --- UI & Scoring (remain the same) ---
        function updateScoreDisplay() { /* ... */ }
        function updateHighScoreDisplay() { /* ... */ }
        function showStartMessage(message = "Loading...", permanent = false) { /* ... */ }
        function hideStartMessage() { /* ... */ }
        // --- Local Storage (remain the same) ---
        function saveHighScore() { /* ... */ }
        function loadHighScore() { /* ... */ }
        // --- Event Handlers (remains the same) ---
        function onWindowResize() { /* ... */ }
        function startGameOnce() { /* ... */ }
        function onKeyDown(event) { /* ... */ }

        // --- Start the experience ---
        init();

    </script>
</body>
</html>
