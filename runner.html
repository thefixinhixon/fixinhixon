<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Runner</title>
    <style>
        /* CSS remains the same */
        body { margin: 0; overflow: hidden; background-color: #222; color: white; font-family: 'Arial', sans-serif; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #gameCanvas { display: block; width: 100%; height: 100%; }
        #uiContainer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; pointer-events: none; font-size: 24px; text-shadow: 1px 1px 2px black; }
        #score { } #highScoreDisplay { }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 28px; pointer-events: all; }
        #gameOverScreen h2 { margin-bottom: 15px; } #finalScore, #sessionHighScore { margin-bottom: 20px; }
        #restartButton { padding: 15px 30px; font-size: 20px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; transition: background-color 0.3s ease; }
        #restartButton:hover { background-color: #45a049; }
        #startMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; text-align: center; background-color: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiContainer">
            <div id="score">Score: 0</div>
            <div id="highScoreDisplay">High Score: 0</div>
        </div>
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <div id="finalScore">Your Score: 0</div>
            <div id="sessionHighScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
         <div id="startMessage">Loading Assets...</div>
    </div>

    <!-- Import map -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        const LANE_WIDTH = 2.5; const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const PLAYER_START_POS = new THREE.Vector3(0, 0, 10);
        const PLAYER_RUN_MODEL_PATH = 'raccoon.glb'; const PLAYER_JUMP_MODEL_PATH = 'raccoon_jump.glb';
        const PLAYER_MODEL_SCALE = 0.02; const ANIMATION_FADE_TIME = 0.2;
        const INITIAL_GAME_SPEED = 8; const MAX_GAME_SPEED = 30; const SPEED_INCREASE_RATE = 0.1;
        const OBSTACLE_SPAWN_Z = -50; const OBSTACLE_DESPAWN_Z = 15;
        const OBSTACLE_SPAWN_INTERVAL_MIN = 0.8; const OBSTACLE_SPAWN_INTERVAL_MAX = 2.0;
        const JUMP_VELOCITY = 10; const GRAVITY = 25; const HIGH_SCORE_KEY = 'raccoonRunnerHighScore';
        const GROUND_TEXTURE_PATHS = [ 'ground1.jpg', 'ground2.jpg', 'ground3.jpg', 'ground4.jpg' ];
        const SKY_TEXTURE_PATH = 'sky.jpg'; const GROUND_TEXTURE_REPEAT = 10;
        // Obstacle model paths still defined, but loading is commented out later
        const TRASHCAN_MODEL_PATH = 'trashcan.glb'; const CACTUS_MODEL_PATH = 'cactus.glb';
        const TRASHCAN_SCALE = 0.8; const CACTUS_SCALE = 0.7;
        // REMOVED FADING CONFIG

        // --- Game State ---
        let scene, camera, renderer, clock, player, ground; // Ground variable still exists
        let gameSpeed = INITIAL_GAME_SPEED; let obstacles = []; let currentLane = 1;
        let score = 0; let highScore = 0; let timeSinceLastSpawn = 0; let nextSpawnInterval = calculateNextSpawnInterval();
        let isJumping = false; let playerVelocityY = 0; let gameState = 'loading'; let animationFrameId = null;
        let playerMixer = null; let playerAnimations = {}; let runAction = null; let jumpAction = null;
        let playerBoundingBox = new THREE.Box3(); let playerHeight = 1;
        let assetsLoaded = false; let gameStartedOnce = false;
        let textureLoader; // Texture loader needed
        let gltfLoader;
        let cachedTrashcanModel = null; // Caching variables remain for createObstacle logic
        let cachedCactusModel = null;
        // REMOVED FADING STATE VARIABLES

        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas'); /* ... */ const startMessage = document.getElementById('startMessage');

        // --- Initialization ---
        function init() {
            console.log("init: Started.");
            textureLoader = new THREE.TextureLoader();
            gltfLoader = new GLTFLoader();
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60); clock = new THREE.Clock();
            const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 4, 15); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7); directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // --- Ground Setup (Simplified) ---
            const groundGeometry = new THREE.PlaneGeometry(40, 150);
            // Create ONE material
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA, // Start with a fallback color
                side: THREE.DoubleSide,
                map: null // Map will be loaded
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial); // Use the single material
            ground.rotation.x = -Math.PI / 2; ground.position.y = 0; ground.receiveShadow = true;
            scene.add(ground);
            console.log("init: Ground mesh created with single material.");

            loadHighScore(); updateHighScoreDisplay();
            console.log("init: Calling loadAssets()...");
            loadAssets().then(() => {
                console.log("init: loadAssets() promise resolved successfully.");
                assetsLoaded = true;
                gameState = 'waiting';
                showStartMessage("Press Any Key or Click to Start");
                window.addEventListener('keydown', startGameOnce);
                window.addEventListener('mousedown', startGameOnce);
                console.log("init: Game ready state set.");
                playAnimation('run');
            }).catch(error => {
                console.error("init: CRITICAL ERROR during asset loading:", error);
                showStartMessage("Error loading assets. Please refresh.", true);
                gameState = 'error';
            });
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            restartButton.addEventListener('click', resetGame);
            console.log("init: Starting animation loop...");
            animate();
            console.log("init: Function finished.");
        }

        // --- Asset Loading (Simplified Ground) ---
        function loadAssets() {
            console.log("loadAssets: Starting...");
            const runPromise = gltfLoader.loadAsync(PLAYER_RUN_MODEL_PATH);
            const jumpPromise = gltfLoader.loadAsync(PLAYER_JUMP_MODEL_PATH);
            const skyPromise = textureLoader.loadAsync(SKY_TEXTURE_PATH);

            // --- Ground Texture Load (Using .load with onError) ---
            const groundLoadPromise = new Promise((resolve, reject) => {
                const initialGroundIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length);
                const initialGroundPath = GROUND_TEXTURE_PATHS[initialGroundIndex];
                console.log("loadAssets: Loading initial ground:", initialGroundPath);
                textureLoader.load(
                    initialGroundPath,
                    (texture) => { // onLoad
                        console.log("loadAssets: Initial ground texture loaded successfully:", initialGroundPath);
                        // Apply properties directly to the texture
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40));
                        // Assign to the single ground material's map
                        ground.material.map = texture;
                        ground.material.needsUpdate = true; // Crucial!
                        console.log("loadAssets: Initial ground texture applied to ground.material.map");
                        resolve(); // Resolve the promise on success
                    },
                    undefined, // onProgress (unused)
                    (errorEvent) => { // onError
                        console.error("loadAssets: FAILED to load initial ground texture:", initialGroundPath, errorEvent);
                        reject(new Error(`Failed to load ground texture: ${initialGroundPath}`)); // Reject promise on error
                    }
                );
            });
            // --- End Ground Texture Load ---


            // --- Obstacle model loading still commented out for testing ---
            // const trashcanPromise = gltfLoader.loadAsync(TRASHCAN_MODEL_PATH);
            // const cactusPromise = gltfLoader.loadAsync(CACTUS_MODEL_PATH);
            // ---

            console.log("loadAssets: Promises created, awaiting Promise.all...");
            // Add groundLoadPromise, remove obstacle promises
            return Promise.all([runPromise, jumpPromise, skyPromise, groundLoadPromise])
                .then(([gltfRun, gltfJump, skyTexture, /* ground load handled by promise */]) => {
                    console.log("loadAssets: Promise.all resolved.");

                    // --- Obstacle model caching still commented out ---
                    // cachedTrashcanModel = gltfTrashcan.scene;
                    // cachedCactusModel = gltfCactus.scene;
                    // ---

                    // Player Model Setup (remains the same)
                    console.log("loadAssets: Setting up player model...");
                    player = gltfRun.scene; player.scale.set(PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE, PLAYER_MODEL_SCALE); player.rotation.y = Math.PI; player.position.set(PLAYER_START_POS.x, 0, PLAYER_START_POS.z); player.traverse(child => { if (child.isMesh) child.castShadow = true; }); scene.add(player); playerBoundingBox.setFromObject(player, true); const ps = new THREE.Vector3(); playerBoundingBox.getSize(ps); playerHeight = ps.y; const mnY = playerBoundingBox.min.y; const go = -mnY; player.position.y = go; player.userData.groundY = go; playerBoundingBox.setFromObject(player, true);
                    console.log("loadAssets: Player model setup complete.");

                    // Animation Setup (remains the same)
                    console.log("loadAssets: Setting up animations...");
                    playerMixer = new THREE.AnimationMixer(player); if (gltfRun.animations && gltfRun.animations.length > 0) { playerAnimations['run'] = gltfRun.animations[0]; runAction = playerMixer.clipAction(playerAnimations['run']); runAction.setLoop(THREE.LoopRepeat); } else { console.warn("No run anim"); } if (gltfJump.animations && gltfJump.animations.length > 0) { playerAnimations['jump'] = gltfJump.animations[0]; jumpAction = playerMixer.clipAction(playerAnimations['jump']); jumpAction.setLoop(THREE.LoopOnce); jumpAction.clampWhenFinished = true;} else { console.warn("No jump anim"); } if (!runAction) { console.error("CRITICAL: Run animation action failed."); }
                    console.log("loadAssets: Animation setup complete.");

                    // Apply Sky Texture
                    console.log("loadAssets: Applying sky texture...");
                    skyTexture.mapping = THREE.EquirectangularReflectionMapping; scene.background = skyTexture; scene.environment = skyTexture;
                    console.log("loadAssets: Sky texture applied.");
                    // REMOVED Ground texture application here (done in groundLoadPromise)
                    // REMOVED preloadNextGroundTexture call

                    console.log("loadAssets: .then() block finished successfully.");

                }).catch(error => {
                     console.error("loadAssets: Error within Promise.all or its .then():", error);
                     throw error;
                });
        }

        // REMOVED preloadNextGroundTexture, startGroundFade, updateGroundFade functions

        // Helper function to play animations (remains the same)
        function playAnimation(name) { /* ... */ }

        // --- Game Loop (Simplified) ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            if (playerMixer) playerMixer.update(deltaTime);
             if (gameState === 'playing') {
                score += deltaTime; updateScoreDisplay();
                 if (gameSpeed < MAX_GAME_SPEED) gameSpeed += SPEED_INCREASE_RATE * deltaTime;
                updatePlayerPosition(deltaTime); handleJump(deltaTime);
                updateObstacles(deltaTime); spawnObstacles(deltaTime);
                checkCollisions();
                // REMOVED Fading logic calls
                 // REMOVED Texture offset logic (can add back later if ground appears)
                 // const textureOffsetY = (clock.elapsedTime * gameSpeed * 0.05) % 1;
                 // if (ground.material.map) ground.material.map.offset.y = textureOffsetY;
            }
            renderer.render(scene, camera);
        }

        // --- Player Logic (remains the same) ---
        function updatePlayerPosition(deltaTime) { /* ... */ }
        function handleJump(deltaTime) { /* ... */ }
        function jump() { /* ... */ }
        function moveLane(direction) { /* ... */ }

        // --- Obstacle Logic (Uses geometric fallbacks) ---
        function createObstacle() { /* ... same as previous version ... */ } // Still uses cachedModel variables which are null
        function updateObstacles(deltaTime) { /* ... same disposal logic ... */ }
        function spawnObstacles(deltaTime) { /* ... */ }
        function calculateNextSpawnInterval() { /* ... */ }

        // --- Collision Detection (remains the same) ---
        function checkCollisions() { /* ... */ }

        // --- Game State Management (Simplified Reset) ---
        function startGame() { /* ... */ }
        function triggerGameOver() { /* ... */ }
        function resetGame() {
            // REMOVED Fading state resets

            // Simplified ground texture reset
            const newGroundIndex = Math.floor(Math.random() * GROUND_TEXTURE_PATHS.length);
            const newGroundPath = GROUND_TEXTURE_PATHS[newGroundIndex];
            console.log("resetGame: Loading new ground texture:", newGroundPath);
            textureLoader.load(newGroundPath,
                (texture) => { // onLoad
                     texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
                     texture.repeat.set(GROUND_TEXTURE_REPEAT, GROUND_TEXTURE_REPEAT * (150/40));
                     ground.material.map = texture;
                     ground.material.needsUpdate = true;
                     console.log("resetGame: Ground texture updated.");
                },
                undefined, // onProgress
                (err) => { // onError
                    console.error("resetGame: Failed to load ground texture:", newGroundPath, err);
                    ground.material.map = null; // Remove map on failure? Or keep old one?
                    ground.material.needsUpdate = true;
                }
            );
            // REMOVED preloadNextGroundTexture call

            if (!player || player.userData.groundY === undefined) return;
            obstacles.forEach(obstacle => { scene.remove(obstacle); obstacle.geometry.dispose(); if(obstacle.material) obstacle.material.dispose(); else obstacle.traverse(c => {if(c.material) c.material.dispose()}); }); obstacles = [];
            player.position.copy(PLAYER_START_POS); player.position.y = player.userData.groundY; playerBoundingBox.setFromObject(player, true); currentLane = 1; isJumping = false; playerVelocityY = 0;
            score = 0; gameSpeed = INITIAL_GAME_SPEED; timeSinceLastSpawn = 0; nextSpawnInterval = calculateNextSpawnInterval();
            updateScoreDisplay(); gameOverScreen.style.display = 'none'; gameState = 'waiting'; gameStartedOnce = false; showStartMessage("Press Any Key or Click to Start");
            if (playerMixer) { if(jumpAction && jumpAction.isRunning()) jumpAction.stop(); if(runAction) runAction.reset().play(); }
            if (clock.running === false) clock.start();
        }

        // --- UI & Scoring (remain the same) ---
        function updateScoreDisplay() { /* ... */ }
        function updateHighScoreDisplay() { /* ... */ }
        function showStartMessage(message = "Loading...", permanent = false) { /* ... */ }
        function hideStartMessage() { /* ... */ }

        // --- Local Storage (remain the same) ---
        function saveHighScore() { /* ... */ }
        function loadHighScore() { /* ... */ }

        // --- Event Handlers (remain the same) ---
        function onWindowResize() { /* ... */ }
        function startGameOnce() { /* ... */ }
        function onKeyDown(event) { /* ... */ }

        // --- Start the experience ---
        init();

    </script>
</body>
</html>
