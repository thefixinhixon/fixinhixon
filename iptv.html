<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple IPTV Player</title>
    <style>
        /* CSS Styles remain the same as Iteration 1.2 */
        body { font-family: sans-serif; margin: 0; background-color: #f0f0f0; display: flex; flex-direction: column; height: 100vh; color: #333; }
        #app-container { display: flex; flex-grow: 1; overflow: hidden; }
        #sidebar { width: 280px; background-color: #e0e0e0; padding: 15px; display: flex; flex-direction: column; border-right: 1px solid #ccc; overflow-y: auto; }
        #main-content { flex-grow: 1; display: flex; flex-direction: column; background-color: #fff; }
        #input-area label, #input-area input[type="text"], #input-area input[type="file"] { display: block; margin-bottom: 5px; width: 100%; box-sizing: border-box; }
        #input-area input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px; }
        #input-area input[type="file"] { padding: 5px 0; margin-bottom: 10px; font-size: 0.9em; }
        #input-area hr { margin: 15px 0; border: 0; border-top: 1px solid #ccc; }
        #input-area .input-group { margin-bottom: 15px; }
        #input-area .input-group label { font-weight: bold; margin-bottom: 3px; font-size: 0.95em; }
        #input-area .input-group span { font-size: 0.85em; color: #555; display: block; margin-bottom: 5px; }
        #input-area button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 100%; }
        #input-area button:hover { background-color: #0056b3; }
        #input-area button:disabled { background-color: #aaa; cursor: not-allowed; }
        #channel-list-container { margin-top: 20px; flex-grow: 1; overflow-y: auto; border: 1px solid #ccc; background-color: #f9f9f9; border-radius: 4px; }
        #channel-list { list-style: none; padding: 0; margin: 0; }
        #channel-list li { padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #eee; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; }
        #channel-list li img.logo { width: 32px; height: auto; margin-right: 10px; flex-shrink: 0; vertical-align: middle; background-color: #ddd; border-radius: 3px; object-fit: contain; }
        #channel-list li:hover { background-color: #d0d0d0; }
        #channel-list li.selected { background-color: #007bff; color: white; font-weight: bold; }
        #video-player-container { background-color: #000; position: relative; width: 100%; padding-top: 56.25%; flex-shrink: 0; }
        #video-player { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
        #epg-container { flex-grow: 1; padding: 15px; overflow: auto; background-color: #f8f9fa; border-top: 1px solid #ccc; }
        #epg-placeholder { color: #888; text-align: center; margin-top: 50px; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; margin: 5px auto 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="sidebar">
            <h2>Settings</h2>
            <div id="input-area">
                <!-- Input fields remain the same -->
                <div class="input-group">
                    <label for="m3u-file">Load M3U File:</label>
                    <input type="file" id="m3u-file" accept=".m3u,.m3u8">
                    <span>OR</span>
                    <label for="m3u-url">Enter M3U URL:</label>
                    <input type="text" id="m3u-url" placeholder="Enter M3U Playlist URL">
                </div>
                <hr>
                <div class="input-group">
                     <label for="epg-file">Load EPG File:</label>
                     <input type="file" id="epg-file" accept=".xml, .xmltv">
                     <span>OR</span>
                     <label for="epg-url">Enter EPG XML URL:</label>
                     <input type="text" id="epg-url" placeholder="Enter EPG XML URL">
                </div>
                <button id="load-button">Load Playlist & EPG</button>
                 <div id="loader" class="loader"></div>
                 <p id="status-message" style="font-size: 0.9em; color: red; margin-top: 10px;"></p>
            </div>
            <h2 style="margin-top: 20px;">Channels</h2>
            <div id="channel-list-container">
                <ul id="channel-list"></ul>
            </div>
        </div>

        <div id="main-content">
            <div id="video-player-container">
                <video id="video-player" controls autoplay>
                    Your browser does not support the video tag.
                </video>
            </div>
            <div id="epg-container">
                 <h2>Electronic Program Guide (EPG)</h2>
                <div id="epg-placeholder">EPG data will appear here after loading.</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="parseM3U.js"></script>

    <script>
        // Constants and variable declarations remain the same
        const m3uUrlInput = document.getElementById('m3u-url');
        const m3uFileInput = document.getElementById('m3u-file');
        const epgUrlInput = document.getElementById('epg-url');
        const epgFileInput = document.getElementById('epg-file');
        const loadButton = document.getElementById('load-button');
        const loader = document.getElementById('loader');
        const statusMessage = document.getElementById('status-message');
        const channelListUl = document.getElementById('channel-list');
        const videoPlayer = document.getElementById('video-player');
        const epgContainer = document.getElementById('epg-container');
        const epgPlaceholder = document.getElementById('epg-placeholder');

        let channels = [];
        let hls = null; // Single HLS instance

        // --- File Reading Utility (Remains the same) ---
        function readFileAsText(file) { /* ... same as 1.2 ... */
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => resolve(event.target.result);
                reader.onerror = (event) => reject(new Error(`Error reading file: ${file.name}`));
                reader.readAsText(file);
            });

        // --- M3U Loading/Parsing (Remains the same) ---
        async function getM3UContent(file, url) { /* ... same as 1.2 ... */
            if (file) {
                console.log(`Reading M3U from local file: ${file.name}`);
                setStatus(`Reading local file: ${file.name}...`, false);
                return await readFileAsText(file);
            } else if (url) {
                console.log(`Fetching M3U from URL: ${url}`);
                setStatus(`Fetching M3U from URL...`, false);
                const cacheBuster = `?_cb=${new Date().getTime()}`;
                const response = await fetch(url + cacheBuster, { cache: 'no-store' });
                if (!response.ok) {
                     console.error(`Failed to fetch M3U. Status: ${response.status} ${response.statusText}. URL: ${response.url}`);
                     let errorText = `Failed to fetch M3U: ${response.status} ${response.statusText}`;
                      if (response.status === 0 || response.type === 'opaque' || response.type === 'error') {
                         errorText += ' (Likely a CORS issue or network problem)';
                      }
                     throw new Error(errorText);
                }
                return await response.text();
            } else {
                throw new Error("No M3U file or URL provided.");
            }
         }

        // --- EPG Loading Placeholder (Remains the same) ---
        async function getEPGContent(file, url) { /* ... same as 1.2 ... */
             if (file) {
                 console.log(`Reading EPG from local file: ${file.name}`);
                 setStatus(`Reading EPG file: ${file.name}...`, false);
                 return await readFileAsText(file);
             } else if (url) {
                 console.log(`Fetching EPG from URL: ${url}`);
                 setStatus(`Fetching EPG from URL...`, false);
                 const cacheBuster = `?_cb=${new Date().getTime()}`;
                 const response = await fetch(url + cacheBuster, { cache: 'no-store' });
                  if (!response.ok) {
                     console.error(`Failed to fetch EPG. Status: ${response.status} ${response.statusText}. URL: ${response.url}`);
                     let errorText = `Failed to fetch EPG: ${response.status} ${response.statusText}`;
                      if (response.status === 0 || response.type === 'opaque' || response.type === 'error') { errorText += ' (Likely CORS issue)'; }
                     throw new Error(errorText);
                 }
                 return await response.text();
             } else {
                 return null; // No EPG source provided
             }

        // --- Display Logic (Remains the same) ---
        function displayChannels(channelData) { /* ... same as 1.2 ... */
            channelListUl.innerHTML = '';
            if (!channelData || channelData.length === 0) { channelListUl.innerHTML = '<li>No channels found or parsed.</li>'; return; }
            channelData.forEach((channel, index) => {
                const li = document.createElement('li');
                li.dataset.url = channel.url; li.dataset.tvgId = channel.tvgId || ''; li.dataset.index = index;
                if (channel.logo) {
                    const img = document.createElement('img');
                    img.src = channel.logo; img.alt = ''; img.classList.add('logo');
                    img.onerror = function() { this.style.display = 'none'; }; img.loading = 'lazy';
                    li.appendChild(img);
                }
                const nameSpan = document.createElement('span');
                nameSpan.textContent = channel.name || `Channel ${index + 1}`;
                li.appendChild(nameSpan);
                li.addEventListener('click', handleChannelClick);
                channelListUl.appendChild(li);
            });

        // --- Event Handlers (handleLoadButtonClick remains the same) ---
        function handleChannelClick(event) { /* ... same as 1.2 ... */
            const currentSelected = channelListUl.querySelector('.selected');
            if (currentSelected) { currentSelected.classList.remove('selected'); }
            const listItem = event.currentTarget;
            listItem.classList.add('selected');
            const index = parseInt(listItem.dataset.index, 10);
            const selectedChannel = channels[index];
            if (selectedChannel) {
                 console.log(`Channel selected: ${selectedChannel.name}, URL: ${selectedChannel.url}, TVG-ID: ${selectedChannel.tvgId}`);
                 playChannel(selectedChannel.url);
                 epgPlaceholder.textContent = `Selected: ${selectedChannel.name}. EPG display pending...`;
            } else {
                 console.error("Could not find channel data for index:", index);
                 setStatus("Error selecting channel.", true);
            }
        async function handleLoadButtonClick() { /* ... same as 1.2 ... */
             const m3uFile = m3uFileInput.files[0];
             const m3uUrl = m3uUrlInput.value.trim();
             const epgFile = epgFileInput.files[0];
             const epgUrl = epgUrlInput.value.trim();

             if (!m3uFile && !m3uUrl) { setStatus("Please select M3U file or enter URL.", true); return; }
             if (m3uFile && m3uUrl) { console.warn("Using M3U file over URL."); m3uUrlInput.value = ''; }
             if (epgFile && epgUrl) { console.warn("Using EPG file over URL."); epgUrlInput.value = ''; }

             clearStatus(); showLoader(true); loadButton.disabled = true;
             channelListUl.innerHTML = '<li>Loading channels...</li>';
             epgPlaceholder.textContent = 'Loading EPG data...';

             try {
                 const m3uText = await getM3UContent(m3uFile, m3uUrl);
                 channels = parseM3U(m3uText);
                 displayChannels(channels);
                 setStatus(channels.length > 0 ? `Loaded ${channels.length} channels.` : `Loaded M3U, but found 0 channels.`, channels.length === 0);

                 setStatus(`Loading EPG data...`, false);
                 const epgText = await getEPGContent(epgFile, epgUrl);
                 if (epgText) {
                     console.log("EPG content loaded. Parsing needed.");
                     epgPlaceholder.textContent = `EPG loaded (${epgFile ? epgFile.name : epgUrl}). Display pending.`;
                     // TODO: parseEPG(epgText);
                 } else {
                     console.log("No EPG source provided.");
                     epgPlaceholder.textContent = 'No EPG source provided.';
                      if (statusMessage.textContent.startsWith('Loading EPG')) clearStatus();
                 }
             } catch (error) {
                 console.error("Error during loading:", error);
                 setStatus(`Error: ${error.message}`, true);
                 channels = []; displayChannels(channels);
                 epgPlaceholder.textContent = 'Failed to load data.';
             } finally {
                 showLoader(false); loadButton.disabled = false;
             }
         }


        // --- Video Player Logic (REVISED) ---
        function playChannel(url) {
            if (!url) {
                setStatus("Cannot play channel: URL is missing.", true);
                console.error("playChannel called with empty URL");
                return;
            }
            console.log(`Attempting to play URL: ${url}`);
            setStatus(`Loading: ${url}`, false);

            // Stop previous playback and destroy HLS instance if it exists
            if (hls) {
                console.log("Destroying previous HLS instance.");
                hls.destroy();
                hls = null;
            }
            // Explicitly stop and reset the native player
            videoPlayer.pause();
            videoPlayer.removeAttribute('src'); // Important to remove src before loading new one
            videoPlayer.load(); // Resets the media element state
             // Clear previous errors? Maybe not, let new errors overwrite.

            // --- Playback Strategy ---
            // 1. Check if HLS.js is supported AND the URL looks like HLS (.m3u8)
            // 2. OR Check if HLS.js is supported AND the URL contains .ts (Speculative attempt for TS streams)
            // 3. Check for native HLS support (.m3u8)
            // 4. Fallback to direct source assignment for other types (including direct .ts if HLS attempts fail or aren't applicable)

            const isPossiblyHls = url.toLowerCase().includes('.m3u8');
            const isTsStream = url.toLowerCase().includes('.ts');

            if (Hls.isSupported() && (isPossiblyHls || isTsStream)) {
                 if (isPossiblyHls) {
                     console.log("URL detected as HLS (.m3u8). Using HLS.js.");
                 } else {
                     console.log("URL contains .ts. Attempting playback with HLS.js (speculative).");
                 }
                hls = new Hls({
                    // --- Potential HLS Config Tweaks ---
                    // debug: true, // Enable verbose HLS.js logging in console
                    // enableWorker: true, // Usually better performance
                    // lowLatencyMode: false, // Set true only if you know it's a LL-HLS stream
                    // fragLoadingMaxRetry: 4, // Increase retries if network is unstable
                    // levelLoadingMaxRetry: 4,
                    // manifestLoadingMaxRetry: 4,
                });

                // Attach error handler *before* loading source
                hls.on(Hls.Events.ERROR, (event, data) => handleHlsError(event, data, url));

                console.log("Loading source into HLS.js...");
                hls.loadSource(url);
                console.log("Attaching HLS.js to video element...");
                hls.attachMedia(videoPlayer);

                hls.once(Hls.Events.MANIFEST_PARSED, () => { // Use 'once' if you only need the first parse event
                    console.log("HLS.js: Manifest parsed successfully.");
                    setStatus(`Playing HLS: ${url}`, false);
                    videoPlayer.play().catch(e => {
                        console.error("Autoplay blocked or failed after HLS manifest parsed:", e);
                        setStatus(`Ready to play (Click play): ${url}`, false);
                    });
                });
                 // Add specific listener for media attachment
                 hls.once(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log("HLS.js: Media element attached.");
                 });
                 // More detailed logging can be added here for other HLS events if needed

            } else if (!isTsStream && videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Primarily Safari, some mobile browsers)
                // Don't try this if we already attempted HLS.js for a .ts stream and failed
                console.log("Using native browser HLS support for .m3u8 URL.");
                videoPlayer.src = url;
                videoPlayer.load(); // Advised for native HLS
                 videoPlayer.play().catch(e => {
                    console.error("Native HLS Autoplay blocked or failed:", e);
                    setStatus(`Ready to play Native HLS (Click play): ${url}`, false);
                });

            } else {
                // Fallback: Try playing directly with the <video> tag
                // This will handle MP4, WebM, potentially some direct .ts (browser dependent), etc.
                console.log(`Attempting direct playback with <video> tag for URL: ${url}`);
                 if (isTsStream) {
                     console.warn("Direct playback of .ts streams in <video> tag has limited browser support and might fail, especially for live streams.");
                 }
                videoPlayer.src = url;
                 videoPlayer.load(); // Good practice to call load
                // Attempt to play, handle autoplay restrictions
                videoPlayer.play().catch(e => {
                    console.error("Direct source Autoplay blocked or failed:", e);
                    setStatus(`Ready to play (Click play): ${url}`, false);
                });
            }


        // --- HLS.js Error Handling (Improved Logging) ---
        function handleHlsError(event, data, url) {
             const errorType = data.type;
             const errorDetails = data.details;
             const isFatal = data.fatal;

             console.error(`HLS.js Error:
               URL: ${url}
               Type: ${errorType}
               Details: ${errorDetails}
               Fatal: ${isFatal}`, data); // Log the full data object

             if (isFatal) {
                 let errorMsg = `Cannot play stream (${errorDetails}).`;
                  switch (errorType) {
                      case Hls.ErrorTypes.NETWORK_ERROR:
                          errorMsg = `Network error (${errorDetails}). Check connection/stream source/CORS.`;
                          if (errorDetails === Hls.ErrorDetails.MANIFEST_LOAD_ERROR || errorDetails === Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT) {
                             errorMsg += " Failed to load the playlist file.";
                          } else if (errorDetails === Hls.ErrorDetails.LEVEL_LOAD_ERROR || errorDetails === Hls.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
                             errorMsg += " Failed to load video segments.";
                          }
                          break;
                      case Hls.ErrorTypes.MEDIA_ERROR:
                           errorMsg = `Media error (${errorDetails}). Stream might be corrupt, use unsupported codecs, or require decryption.`;
                           // Attempt recovery? (Sometimes helps for segment errors)
                           if (data.details === Hls.ErrorDetails.FRAG_DECRYPT_ERROR){
                                errorMsg += " Decryption failed (DRM?).";
                           } else if (hls && data.details !== Hls.ErrorDetails.BUFFER_APPEND_ERROR /* Don't destroy on simple append error? */ ) {
                              console.warn("Attempting HLS.js media error recovery...");
                              // hls.recoverMediaError(); // Use with caution, might loop
                              // hls.swapAudioCodec(); // If you suspect audio issues
                           }
                           break;
                       case Hls.ErrorTypes.MUX_ERROR:
                            errorMsg = `Muxing/Transmuxing error (${errorDetails}). Problem processing segments.`;
                            break;
                       case Hls.ErrorTypes.KEY_SYSTEM_ERROR:
                            errorMsg = `DRM Key System error (${errorDetails}).`;
                            break;
                      default: // Other fatal errors
                           errorMsg = `Fatal playback error (${errorType} - ${errorDetails}).`;
                           break;
                  }
                  setStatus(`HLS Error: ${errorMsg}`, true);
                  // Destroy HLS instance on most fatal errors
                   if (hls) { // Check if hls still exists
                       console.log("Destroying HLS instance due to fatal error.");
                       hls.destroy();
                       hls = null;
                   }

             } else {
                 // Non-fatal errors
                 console.warn(`HLS.js Non-fatal error: Type: ${errorType}, Details: ${errorDetails}`);
                 if (errorDetails === Hls.ErrorDetails.BUFFER_STALLED_ERROR) {
                    setStatus('Buffering stalled...', false);
                 } else if (errorDetails.includes('BUFFER_NUDGE_ON_STALL')) {
                    console.log('HLS performing buffer nudge...');
                 }
             }
         }

        // --- Utility Functions (Remain the same) ---
        function showLoader(show) { loader.style.display = show ? 'block' : 'none'; }
        function setStatus(message, isError = false) { statusMessage.textContent = message; statusMessage.style.color = isError ? 'red' : '#333'; if (isError) console.error("Status:", message); else console.log("Status:", message); }
        function clearStatus() { statusMessage.textContent = ''; }

        // --- Video Element Error Handling (Enhanced Logging) ---
        videoPlayer.addEventListener('error', (e) => {
             let errorMsg = "Unknown video element error.";
             const videoEl = e.target; // Get the video element itself
             const error = videoEl.error;
             const currentSrc = videoEl.currentSrc; // Log the source it tried to play
             const isHlsManaged = !!hls; // Is HLS.js currently active?

             if (error) {
                 switch (error.code) {
                     case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Playback aborted by user or script.'; break;
                     case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Network error loading video data.'; break;
                     case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Video decoding error. Corrupt data or unsupported codec.'; break;
                     case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Source format not supported, or URL invalid/unreachable (check CORS?).'; break;
                     default: errorMsg = `Unknown media error (Code ${error.code}, Message: ${error.message || 'N/A'}).`;
                 }
             }
             console.error(`HTML Video Element Error:
               Message: ${errorMsg}
               Code: ${error?.code || 'N/A'}
               Source URL: ${currentSrc}
               HLS Active: ${isHlsManaged}`, error); // Log original event/error object

             // Update status ONLY if HLS isn't active OR if it's a fundamental source issue
             // Avoid double-reporting if HLS already reported a fatal error.
             if (!isHlsManaged || error?.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
                  setStatus(`Video Error: ${errorMsg}`, true);
             } else if (isHlsManaged) {
                 console.warn("Video element error occurred while HLS was active. Primary error likely reported by HLS.js.");
             }
         });

         // Other video events remain useful for debugging
          videoPlayer.addEventListener('stalled', (e) => console.warn("Video stalled (download paused). Source:", e.target.currentSrc));
          videoPlayer.addEventListener('waiting', (e) => { console.log("Video waiting for data (buffering)... Source:", e.target.currentSrc); setStatus("Buffering...", false); });
          videoPlayer.addEventListener('playing', (e) => { console.log("Video playback started/resumed. Source:", e.target.currentSrc); if (statusMessage.textContent === "Buffering...") clearStatus(); });
          videoPlayer.addEventListener('loadedmetadata', (e) => console.log("Video metadata loaded. Source:", e.target.currentSrc));
          videoPlayer.addEventListener('canplay', (e) => console.log("Video can play (enough data). Source:", e.target.currentSrc));


        // --- Initial Setup (Input clearing listeners remain the same) ---
        loadButton.addEventListener('click', handleLoadButtonClick);
        m3uFileInput.addEventListener('change', () => { if (m3uFileInput.files.length > 0) m3uUrlInput.value = ''; });
        m3uUrlInput.addEventListener('input', () => { if (m3uUrlInput.value.trim() !== '') m3uFileInput.value = null; });
        epgFileInput.addEventListener('change', () => { if (epgFileInput.files.length > 0) epgUrlInput.value = ''; });
        epgUrlInput.addEventListener('input', () => { if (epgUrlInput.value.trim() !== '') epgFileInput.value = null; });

        console.log("IPTV Player Initialized.");
        setStatus("Select M3U file or enter URL, then click Load.", false);
        if (typeof Hls === 'undefined') { console.error("HLS.js not found!"); setStatus("HLS.js library missing!", true); }
        else { console.log(`HLS.js Version: ${Hls.version || 'Unknown'}`); }

    </script>

</body>
</html>
