<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Added viewport meta for mobile -->
  <title>Starfield, Raster Bars & Dynamic Waving Text Flag</title>
  <!-- Preconnect and load "Jersey 10" from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jersey+10&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
      height: 100%;
      width: 100%; /* Ensure full width */
      touch-action: none; /* Prevent default touch actions like scrolling/zooming page */
    }
    canvas {
      display: block;
      /* width/height set by JS */
    }
    /* Hide the audio controls if needed */
    #backgroundMusic {
       position: absolute;
       top: -9999px;
       left: -9999px;
    }
  </style>
</head>
<body>
  <canvas id="mainCanvas"></canvas>
  <!-- Add the audio element -->
  <audio id="backgroundMusic" src="music.mp3" loop preload="auto"></audio>

  <script>
    (function() {
      "use strict";

      const canvas = document.getElementById("mainCanvas");
      const ctx = canvas.getContext("2d");
      const bgMusic = document.getElementById("backgroundMusic"); // Get audio element
      let musicStarted = false; // Flag to track if music has started

      // --- Utility Functions ---
      function distance(p1, p2) {
          const dx = p1.clientX - p2.clientX;
          const dy = p1.clientY - p2.clientY;
          return Math.hypot(dx, dy);
      }

      function angle(p1, p2) {
          const dx = p1.clientX - p2.clientX;
          const dy = p1.clientY - p2.clientY;
          return Math.atan2(dy, dx);
      }

      function getTouchCenter(touches) {
         let centerX = 0, centerY = 0;
         for(const touch of touches) {
            centerX += touch.clientX;
            centerY += touch.clientY;
         }
         return { x: centerX / touches.length, y: centerY / touches.length };
      }

      // --- Initial Setup & Resize ---
      function resizeMainCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // Update related components on resize
        if (stars.length > 0) { // Check if stars initialized
            stars.forEach(star => { // Adjust existing star positions proportionally
              star.x = star.x / (canvas.previousWidth || canvas.width) * canvas.width;
              star.y = star.y / (canvas.previousHeight || canvas.height) * canvas.height;
            });
        }
        canvas.previousWidth = canvas.width; // Store for next resize
        canvas.previousHeight = canvas.height;
        updateFlagCanvas(); // Recalculate flag canvas based on new size
        barCenter = canvas.height / 2;
      }
      window.addEventListener("resize", resizeMainCanvas);
      // Initialize canvas size
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      canvas.previousWidth = canvas.width;
      canvas.previousHeight = canvas.height;


      // --- Starfield Setup ---
      const stars = [];
      const numStars = 150;
      for (let i = 0; i < numStars; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          speed: Math.random() * 0.5 + 0.2,
          radius: Math.random() * 1.5 + 0.5
        });
      }

      // --- Raster Bars Setup ---
      const resolution = 25;
      const barSpeed = 0.01;
      let barCenter = canvas.height / 2;
      const barSize = 50;
      const step = Math.PI * 2 / resolution;
      const bars = [
        new RasterBar(step, barSize, barSpeed, [255, 32, 255]),
        new RasterBar(step, barSize, barSpeed, [32, 255, 255]),
        new RasterBar(step, barSize, barSpeed, [255, 255, 32])
      ];
      let t = 0;

      // --- Text Flag Setup ---
      let flagCanvas = document.createElement("canvas");
      let flagWidth = 1600, flagHeight = 600;
      flagCanvas.width = flagWidth;
      flagCanvas.height = flagHeight;
      const fctx = flagCanvas.getContext("2d");
      const lines = [
        "THE GREENERY ROOM!",
        "CANNABIS DISPENSARY & LOUNGE!",
        "2330 SUDDERTH DRIVE, RUIDOSO, NM!"
      ];
      const suggestedFontSize = 100;
      const desiredMargin = 0.9;
      const lineHeightFactor = 1.0;
      let finalFontSize = suggestedFontSize;

      function updateFlagCanvas() {
        flagWidth = canvas.width * 1.5; // Keep flag relatively large
        flagHeight = canvas.height * 0.5; // Adjust height based on viewport
        // Ensure minimum dimensions for very small screens if needed
        flagWidth = Math.max(flagWidth, 800);
        flagHeight = Math.max(flagHeight, 300);

        flagCanvas.width = flagWidth;
        flagCanvas.height = flagHeight;
        fctx.clearRect(0, 0, flagWidth, flagHeight);

        finalFontSize = suggestedFontSize;
        fctx.font = suggestedFontSize + "px 'Jersey 10', sans-serif";
        for (let i = 0; i < lines.length; i++) {
          const w = fctx.measureText(lines[i]).width;
          const ratio = (flagWidth * desiredMargin) / w;
          if (w > 0 && ratio < 1) { // Check w > 0 to avoid division by zero
              finalFontSize = Math.min(finalFontSize, suggestedFontSize * ratio);
          }
        }
        // Ensure a minimum font size
        finalFontSize = Math.max(finalFontSize, 20); // e.g., min 20px

        fctx.font = finalFontSize + "px 'Jersey 10', sans-serif";
        fctx.textAlign = "center";
        fctx.textBaseline = "middle";
        fctx.fillStyle = "white";
        const lineHeight = finalFontSize * lineHeightFactor;
        const totalTextHeight = lines.length * lineHeight;
        let startY = (flagHeight - totalTextHeight) / 2 + lineHeight / 2;
        // Clamp startY to prevent text going off canvas if flagHeight is too small
        startY = Math.max(startY, lineHeight / 2);

        for (let i = 0; i < lines.length; i++) {
            // Clamp Y position of individual lines as well
            const lineY = Math.min(startY + i * lineHeight, flagHeight - lineHeight / 2);
            fctx.fillText(lines[i], flagWidth / 2, lineY);
        }
      }
      // Initial call after vars are defined
      updateFlagCanvas();


      // --- Flag Simulation Parameters ---
      let flagTime = 0;
      const waveSpeed = 2.0;
      const amplitude = 20;
      let rotationAngle = 0;
      let flagScale = 1.0;
      const minFlagScale = 0.3; // Minimum zoom level
      const maxFlagScale = 5.0; // Maximum zoom level

      // --- Interaction Logic ---
      let activeTouches = new Map();
      let initialPinchDistance = null;
      let initialPinchScale = null;
      let initialRotateAngle = null;
      let initialRotateRotation = null;

      // Function to attempt starting music (called on first interaction)
      function tryStartMusic() {
        if (!musicStarted) {
          bgMusic.play().then(() => {
            musicStarted = true;
            console.log("Background music started.");
          }).catch(error => {
            console.error("Audio autoplay failed:", error);
            // Maybe show a message to the user that they need to interact
          });
        }
      }

      // --- Keyboard Controls ---
      window.addEventListener("keydown", function(e) {
        tryStartMusic(); // Start music on first keydown
        const rotationDelta = 0.1;
        const scaleDelta = 0.1;
        if (e.key === "ArrowLeft") {
          rotationAngle -= rotationDelta;
        } else if (e.key === "ArrowRight") {
          rotationAngle += rotationDelta;
        } else if (e.key === "ArrowUp") {
          flagScale = Math.min(maxFlagScale, flagScale + scaleDelta); // Use max scale limit
        } else if (e.key === "ArrowDown") {
          flagScale = Math.max(minFlagScale, flagScale - scaleDelta); // Use min scale limit
        }
      });

      // --- Touch Controls Setup ---
      // Check for touch support
      const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

      if (isMobile) {
        canvas.addEventListener("touchstart", handleTouchStart, { passive: false }); // Need preventDefault
        canvas.addEventListener("touchmove", handleTouchMove, { passive: false }); // Need preventDefault
        canvas.addEventListener("touchend", handleTouchEnd);
        canvas.addEventListener("touchcancel", handleTouchEnd); // Handle cancellation too
      }

      function handleTouchStart(e) {
        e.preventDefault(); // Prevent page scroll/zoom
        tryStartMusic(); // Start music on first touch

        for (const touch of e.changedTouches) {
            activeTouches.set(touch.identifier, {
                identifier: touch.identifier,
                clientX: touch.clientX,
                clientY: touch.clientY
            });
        }

        if (activeTouches.size === 2) {
            const touches = Array.from(activeTouches.values());
            initialPinchDistance = distance(touches[0], touches[1]);
            initialPinchScale = flagScale;
            initialRotateAngle = angle(touches[0], touches[1]);
            initialRotateRotation = rotationAngle;
        } else {
            // Reset gesture tracking if not exactly two fingers
            initialPinchDistance = null;
            initialRotateAngle = null;
        }
      }

      function handleTouchMove(e) {
        e.preventDefault(); // Prevent page scroll/zoom during move

        // Update touch positions
         for (const touch of e.changedTouches) {
            if (activeTouches.has(touch.identifier)) {
                const existingTouch = activeTouches.get(touch.identifier);
                existingTouch.clientX = touch.clientX;
                existingTouch.clientY = touch.clientY;
            }
        }

        if (activeTouches.size === 2) {
            const touches = Array.from(activeTouches.values());
            // Pinch to Zoom
            if (initialPinchDistance !== null && initialPinchScale !== null) {
                const currentDistance = distance(touches[0], touches[1]);
                let targetScale = initialPinchScale * (currentDistance / initialPinchDistance);
                // Clamp scale
                flagScale = Math.max(minFlagScale, Math.min(maxFlagScale, targetScale));
            }
            // Two-finger Rotate
            if (initialRotateAngle !== null && initialRotateRotation !== null) {
                const currentAngle = angle(touches[0], touches[1]);
                const angleDelta = currentAngle - initialRotateAngle;
                rotationAngle = initialRotateRotation + angleDelta;
            }
        }
      }

      function handleTouchEnd(e) {
         for (const touch of e.changedTouches) {
            activeTouches.delete(touch.identifier);
        }

        // If less than 2 touches remain, stop tracking gestures
        if (activeTouches.size < 2) {
            initialPinchDistance = null;
            initialRotateAngle = null;
            initialPinchScale = null; // Also reset initial scale/rotation
            initialRotateRotation = null;
        }
         // If exactly 2 touches *still* remain (e.g., a 3rd finger was lifted),
         // re-initialize the gesture tracking with the remaining two
         else if (activeTouches.size === 2) {
             const touches = Array.from(activeTouches.values());
             initialPinchDistance = distance(touches[0], touches[1]);
             initialPinchScale = flagScale;
             initialRotateAngle = angle(touches[0], touches[1]);
             initialRotateRotation = rotationAngle;
         }
      }


      // --- Global Animation Time ---
      let uTime = 0;
      let lastTime = performance.now();

      // Main animation loop.
      function loop() {
        let now = performance.now();
        let delta = (now - lastTime) * 0.001; // seconds.
        lastTime = now;
        uTime += delta;
        flagTime += delta;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- Draw Starfield ---
        for (let i = 0; i < stars.length; i++) {
          let star = stars[i];
          // Ensure star speed isn't excessively high due to large delta on lag/resume
          star.y += star.speed * Math.min(delta * 100, 5); // Adjust speed based on delta, clamp effect

          if (star.y > canvas.height + star.radius * 2) { // Check beyond canvas edge
            star.y = -star.radius * 2; // Reset above the top
            star.x = Math.random() * canvas.width;
          } else if (star.y < -star.radius * 2) { // Handle potential negative speed if added later
             star.y = canvas.height + star.radius * 2;
             star.x = Math.random() * canvas.width;
          }

          let twinkle = 0.5 + 0.5 * Math.sin(uTime * 2 + star.x * 0.01); // Faster twinkle
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.radius * twinkle, 0, Math.PI * 2);
          ctx.fillStyle = "white";
          ctx.fill();
        }

        // --- Draw Raster Bars ---
        t += 0.03 * Math.min(delta * 60, 3); // Adjust speed based on delta, clamp effect
        if (t > Math.PI * 2) t -= Math.PI * 2; // Use subtraction instead of reset to 0 for smoother wrap
        let pass = 3;
        let sinValue, drawPosition, y;
        while (--pass) {
          for (let i = 0; i < bars.length; i++) {
            sinValue = t + i * Math.PI * 2 / bars.length;
            drawPosition = Math.sin(sinValue - Math.PI/2);
            y = barCenter + Math.round(120 * Math.sin(sinValue)); // 120 is amplitude of bar vertical movement
            if (pass === 2 && drawPosition < 0) {
              bars[i].draw(y);
            } else if (pass === 1 && drawPosition >= 0) {
              bars[i].draw(y);
            }
          }
        }

        // --- Draw Waving Text Flag ---
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2); // Translate to center
        ctx.rotate(rotationAngle); // Apply rotation
        ctx.scale(flagScale, flagScale); // Apply scale
        // Calculate position *after* scaling/rotation to draw centered
        const flagDrawX = -flagWidth/2;
        const flagDrawY = -flagHeight/2;

        const waveTime = flagTime * waveSpeed;
        const sliceHeight = 2; // Draw in slices for wave effect

        for (let y = 0; y < flagHeight; y += sliceHeight) {
          // Calculate wave offset based on vertical position (y) and time
          // Adding a horizontal component to the wave calculation makes it look more cloth-like
          // let offset = amplitude * Math.sin((y / flagHeight) * 3 * Math.PI + waveTime); // Only vertical wave
           let offset = amplitude * Math.sin( (y / (flagHeight*0.8)) * Math.PI * 1.5 /* vertical freq */
                                            + waveTime /* horizontal motion */
                                           );

          // Ensure we don't draw past the source canvas height
          const sourceHeight = Math.min(sliceHeight, flagCanvas.height - y);
          if (sourceHeight <= 0) continue;

          ctx.drawImage(
            flagCanvas,       // Source canvas (the text)
            0, y,             // Source X, Y
            flagWidth, sourceHeight, // Source Width, Height
            flagDrawX + offset, // Destination X (with wave offset)
            flagDrawY + y,      // Destination Y
            flagWidth, sourceHeight  // Destination Width, Height
          );
        }
        ctx.restore();

        requestAnimationFrame(loop);
      }

      // --- RasterBar Definition ---
      function RasterBar(step, size, speed, color) {
        this.step = step;
        this.size = size;
        this.speed = speed;
        this.color = color; // Store as array [R, G, B]
        this.offset = 0;
      }

      RasterBar.prototype.draw = function(position) {
        // Adjust speed based on delta time for consistent speed? - Less critical for raster bars usually
        this.offset += this.speed;
        if (this.offset > this.step) this.offset -= this.step; // Use subtraction for smooth wrap

        let prevY = 0;
        let t = this.offset;
        let y, height, f, r, g, b;
        const centerLine = this.size; // The line around which the sine wave oscillates

        // Precompute color components for slight optimization
        const baseR = this.color[0];
        const baseG = this.color[1];
        const baseB = this.color[2];

        // Iterate through sine wave segments to draw bands
        while (t < Math.PI + this.offset) {
            // Calculate the top Y of the current band segment based on sine wave
            // The sine wave defines the *center* density, so we adjust position
            // Using 1.5*PI offset starts the sine wave from its minimum (-1)
            y = Math.round(this.size * Math.sin(1.5 * Math.PI + t)) + centerLine;
            height = Math.max(1, y - prevY); // Ensure minimum height of 1px

            // Calculate fade factor based on distance from the center of the bar effect
            // f = 1 at the center (y = this.size), f = 0 at the edges (y = 0 or y = 2 * this.size)
            // We calculate based on the middle of the *current band* being drawn
            const bandCenterY = prevY + height / 2;
            f = 1 - Math.abs(centerLine - bandCenterY) / centerLine;
            f = Math.max(0, Math.min(1, f)); // Clamp f between 0 and 1

            // Calculate final color based on fade factor
            r = Math.round(f * baseR);
            g = Math.round(f * baseG);
            b = Math.round(f * baseB);

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            // Draw the band at the calculated vertical 'position' offset
            ctx.fillRect(0, prevY + position - centerLine, canvas.width, height); // Adjust position by centerLine

            t += this.step;
            prevY = y;
        }
      };

      // Start the loop
      resizeMainCanvas(); // Call resize initially to set correct sizes
      requestAnimationFrame(loop);

    })();
  </script>
</body>
</html>